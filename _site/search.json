[
  {
    "objectID": "tidyverse.html",
    "href": "tidyverse.html",
    "title": "Introducción a tidyverse",
    "section": "",
    "text": "Este material es parte de la Unidad 1 del curso de Epidemiología - Nivel Avanzado  © 2025 Instituto Nacional de Epidemiología “Dr. Juan H. Jara” (ANLIS) -  CC BY-NC 4.0",
    "crumbs": [
      "Introducción a tidyverse"
    ]
  },
  {
    "objectID": "tidyverse.html#introducción",
    "href": "tidyverse.html#introducción",
    "title": "Introducción a tidyverse",
    "section": "Introducción",
    "text": "Introducción\nTidyverse es el nombre que se ha dado al conjunto de paquetes desarrollados o apoyados por Hadley Wickham (jefe científico de Posit/RStudio) y su equipo, para ciencia de datos con R.\nTodos estos paquetes están diseñados para funcionar juntos y comparten una misma filosofía, que se puede consultar en The tidy tools manifesto.\nLos cuatro principios básicos en los que se basa son:\n\nReutilizar las estructuras de datos\nResolver problemas complejos combinando varias piezas sencillas\nUtilizar programación funcional\nDiseño para humanos\n\nLos paquetes incluidos en el tidyverse tienen como objetivo cubrir todas las fases del análisis de datos dentro de R: importar datos, ponerlos en formato ordenado (tidy data), buscar relaciones entre ellos (mediante su transformación, visualización y creación de modelos) y comunicar los resultados.\nLa palabra “tidy” se puede traducir como “ordenado” y refiere a que los datos deben cumplir con una estructura determinada donde:\n\nCada variable es una columna de la tabla de datos.\nCada observación es una fila de la tabla de datos.\nCada tabla responde a una unidad de observación o análisis.\n\n\n\n\n\n\nAdemás de los paquetes principales que realizan estas funciones, al instalar el tidyverse también se proporcionan otros que ayudan a trabajar con fechas, cadenas de caracteres o factores siguiendo los mismos principios.\nUna de las interesantes incorporaciones transversales en el ambiente tidyverse es el uso de tuberías (del inglés pipe).\nUna tubería conecta un trozo de código con otro mediante el conector |&gt; que surge del paquete magrittr que permite transformar llamadas de funciones anidadas (con muchos paréntesis) en una simple serie de operaciones que son más fáciles de escribir y comprender. A partir de la versión 4.1.0 de R existe una tubería similar en su versión nativa (|&gt;). El uso de cualquiera de ellas es similar.\nResponde al principio donde cada función es un paso y la forma de trabajar se puede ver en el siguiente esquema general:\n\n\n\n\n\nMostramos el funcionamiento básico comparativo en la siguiente porción de código:\n\n# Utilizamos para la demostración el dataset mtcars incorporado en R (datos sobre autos)\n\nhead(sqrt(mtcars)) \n\n                       mpg      cyl     disp        hp     drat       wt\nMazda RX4         4.582576 2.449490 12.64911 10.488088 1.974842 1.618641\nMazda RX4 Wag     4.582576 2.449490 12.64911 10.488088 1.974842 1.695582\nDatsun 710        4.774935 2.000000 10.39230  9.643651 1.962142 1.523155\nHornet 4 Drive    4.626013 2.449490 16.06238 10.488088 1.754993 1.793042\nHornet Sportabout 4.324350 2.828427 18.97367 13.228757 1.774824 1.854724\nValiant           4.254409 2.449490 15.00000 10.246951 1.661325 1.860108\n                      qsec vs am     gear     carb\nMazda RX4         4.057093  0  1 2.000000 2.000000\nMazda RX4 Wag     4.125530  0  1 2.000000 2.000000\nDatsun 710        4.313931  1  1 2.000000 1.000000\nHornet 4 Drive    4.409082  1  0 1.732051 1.000000\nHornet Sportabout 4.125530  0  0 1.732051 1.414214\nValiant           4.496665  1  0 1.732051 1.000000\n\n# en la línea de código de arriba estamos pidiendo mostrar la cabecera (6 primeras \n# observaciones de la tabla de datos) de la raíz cuadrada de los valores de la tabla mtcars, \n# en formato del lenguaje clásico (anidado)\n\n# Ahora activamos maggritr (viene incorporado con tidyverse)\n\nlibrary(magrittr) \n\n# ejecutamos la línea anterior convertida al formato tubería\n\nmtcars |&gt;\n  sqrt() |&gt;\n  head()\n\n                       mpg      cyl     disp        hp     drat       wt\nMazda RX4         4.582576 2.449490 12.64911 10.488088 1.974842 1.618641\nMazda RX4 Wag     4.582576 2.449490 12.64911 10.488088 1.974842 1.695582\nDatsun 710        4.774935 2.000000 10.39230  9.643651 1.962142 1.523155\nHornet 4 Drive    4.626013 2.449490 16.06238 10.488088 1.754993 1.793042\nHornet Sportabout 4.324350 2.828427 18.97367 13.228757 1.774824 1.854724\nValiant           4.254409 2.449490 15.00000 10.246951 1.661325 1.860108\n                      qsec vs am     gear     carb\nMazda RX4         4.057093  0  1 2.000000 2.000000\nMazda RX4 Wag     4.125530  0  1 2.000000 2.000000\nDatsun 710        4.313931  1  1 2.000000 1.000000\nHornet 4 Drive    4.409082  1  0 1.732051 1.000000\nHornet Sportabout 4.125530  0  0 1.732051 1.414214\nValiant           4.496665  1  0 1.732051 1.000000\n\n# lo mismo con la tubería nativa de R (no hay que activar ningún paquete)\n\nmtcars |&gt; \n  sqrt() |&gt; \n  head()\n\n                       mpg      cyl     disp        hp     drat       wt\nMazda RX4         4.582576 2.449490 12.64911 10.488088 1.974842 1.618641\nMazda RX4 Wag     4.582576 2.449490 12.64911 10.488088 1.974842 1.695582\nDatsun 710        4.774935 2.000000 10.39230  9.643651 1.962142 1.523155\nHornet 4 Drive    4.626013 2.449490 16.06238 10.488088 1.754993 1.793042\nHornet Sportabout 4.324350 2.828427 18.97367 13.228757 1.774824 1.854724\nValiant           4.254409 2.449490 15.00000 10.246951 1.661325 1.860108\n                      qsec vs am     gear     carb\nMazda RX4         4.057093  0  1 2.000000 2.000000\nMazda RX4 Wag     4.125530  0  1 2.000000 2.000000\nDatsun 710        4.313931  1  1 2.000000 1.000000\nHornet 4 Drive    4.409082  1  0 1.732051 1.000000\nHornet Sportabout 4.125530  0  0 1.732051 1.414214\nValiant           4.496665  1  0 1.732051 1.000000\n\n# la tubería le da mucha mas claridad al código separandolo en partes, como \n# si fuesen oraciones de un párrafo\n\nBase gramatical\nLa intención de los desarrolladores para este conjunto de paquetes es lograr incorporar una gramática a la sintaxis de las funciones y sus argumentos buscando un entendimiento semántico más claro.\nUna prueba de ello, es que la mayoría de las funciones son verbos (en ingles) que se entrelazan con objetos y argumentos que permiten construir “frases”. Ejemplo de ello se muestra en paquetes como dplyr.",
    "crumbs": [
      "Introducción a tidyverse"
    ]
  },
  {
    "objectID": "tidyverse.html#paquete-tidyverse",
    "href": "tidyverse.html#paquete-tidyverse",
    "title": "Introducción a tidyverse",
    "section": "Paquete tidyverse",
    "text": "Paquete tidyverse\nEl paquete tidyverse base actual (versión 2.0.0) se puede descargar del repositorio oficial CRAN mediante menú Packages de RStudio o ejecutando:\n\ninstall.packages(\"tidyverse\")\n\nSe activa mediante:\n\nlibrary(tidyverse)\n\nobservamos que nos informa sobre la versión del paquete, el listado de paquetes que acabamos de activar sólo llamando a tidyverse y una serie de conflictos de nombres de funciones.\nEsto es muy habitual cuando activamos varios paquetes, dado que las funciones que se encuentran dentro de ellos pueden llamarse iguales.\nPor ejemplo, existe en el paquete base stats y en el paquete dplyr (que es parte de tidyverse) una función llamada filter(), por lo tanto al activar tidyverse nos informa de esta manera: dplyr::filter() masks stats::filter()\nEn este caso, cuando necesitemos asegurarnos que la función que deseamos ejecutar pertenece a determinado paquete, es recomendable escribirla de la siguiente forma:\n\nnombre_paquete::nombre_función\n\nstats:filter() para la función filter() del paquete stats\ndplyr:filter() para la función filter() del paquete dplyr\nLos paquetes incluidos que se instalan en esta versión son:\n\ntidyverse_packages()\n\n [1] \"broom\"         \"conflicted\"    \"cli\"           \"dbplyr\"       \n [5] \"dplyr\"         \"dtplyr\"        \"forcats\"       \"ggplot2\"      \n [9] \"googledrive\"   \"googlesheets4\" \"haven\"         \"hms\"          \n[13] \"httr\"          \"jsonlite\"      \"lubridate\"     \"magrittr\"     \n[17] \"modelr\"        \"pillar\"        \"purrr\"         \"ragg\"         \n[21] \"readr\"         \"readxl\"        \"reprex\"        \"rlang\"        \n[25] \"rstudioapi\"    \"rvest\"         \"stringr\"       \"tibble\"       \n[29] \"tidyr\"         \"xml2\"          \"tidyverse\"    \n\n\nExisten otros paquetes (la cantidad crece mes a mes) que son creados bajo la misma filosofía pero no están incluidos. En esos casos hay que instalarlos y activarlos individualmente.\nPara profundizar sobre tidyverse, se puede visitar el sitio https://www.tidyverse.org/ y el libro traducido al español r4ds o la nueva versión r4ds 2e, por ahora solo en inglés.",
    "crumbs": [
      "Introducción a tidyverse"
    ]
  },
  {
    "objectID": "tidyverse.html#lectura-y-escritura-de-datos",
    "href": "tidyverse.html#lectura-y-escritura-de-datos",
    "title": "Introducción a tidyverse",
    "section": "Lectura y escritura de datos",
    "text": "Lectura y escritura de datos\n\nPaquete readr\nreadr contiene funciones similares a las de la familia read.table() de Rbase pero desarrollados bajo el ecosistema tidyverse.\nLos archivos de texto plano (ASCII y otras codificaciones) son universalmente utilizados por la mayoría de los gestores de bases de datos y/o planillas de cálculo. Generalmente encontrados con extensiones .txt o .csv (por comma-separated values) son el tipo de archivo de datos más habitual dentro del lenguaje R.\nEstos datos planos tienen dos peculiaridades:\n\nLa cabecera (en inglés header)\nEl caracter o símbolo separador que indica la separación de columnas: pueden estar separadas por comas, puntos y comas, por tabulación, etc…\n\nLa cabecera puede existir o no, y la inclusión o no de la cabecera se maneja desde los argumentos col_names y skip.\nCon col_names = TRUE incluimos la primer fila como cabecera (nombre de las columnas) y en FALSE la salteamos.\nCon skip = 0 la lectura de produce desde la primer fila (se puede omitir), pero si la cabecera fuese compleja con varias filas entre títulos y subtítulos, debemos indicar cuantas filas iniciales se “saltea”. Por ejemplo con skip = 5 se saltea las primeras 5 filas del archivo.\nEl otro elemento a tener en cuenta es el caracter separador que utiliza el archivo para indicar cuando comienza una nueva columna (variable).\nGeneralmente los separadores más comunes son: la coma (,), el punto y coma (;), el tabulador (TAB), el espacio ( ), el caracter pipe (|), entre otros posibles.\nAlgunas de las funciones del paquete asumen un separador particular. Por caso read_csv() lee separados por coma y read_tsv() separado por tabulaciones, pero la función read_delim() permite que definamos el separador a través del argumento delim.\nEn forma detallada el paquete readr soporta siete formatos de archivo a partir de siete funciones:\n\nread_csv(): archivos separados por comas (CSV)\nread_tsv(): archivos separados por tabulaciones\nread_delim(): archivos separados con delimitadores generales\nread_fwf(): archivos con columnas de ancho fijo\nread_table(): archivos formato tabla con columnas separadas por espacios\nread_log(): archivos log web\n\nEn comparación con las funciones base de R, las funciones de readr:\n\nUsan un esquema de nombres consistente de parámetros\nSon más rápidas.\nAnalizan eficientemente los formatos de datos comunes, incluyendo fecha/hora.\nMuestran una barra de progreso si la carga va a llevar un tiempo. (para archivos grandes)\n\nViene incluida dentro de la instalación de tidyverse y se activa con él, pero también permite activarse solo:\n\nlibrary(readr)\n\nAlgunos ejemplos de sintaxis:\n\nLeemos un archivo sin cabecera separado por comas bajo el nombre datos:\n\n\n\n\n\n\n\n9,Leone,Fernando,M,1958-12-24\n26,Garcia,Laura,M,1954-01-21\n35,Salamone,Nicolas,M,1993-06-27\n48,Gonzalez,Viviana,F,1965-06-21\n\n\n\n\ndatos &lt;- read_csv(\"datos/ejemplo-datos.csv\", \n                  col_names = F)\n\n\nLeemos el mismo archivo con cabecera y separado por punto y comas, bajo el nombre info\n\n\n\n\n\n\n\nIden;Apellido;Nombre;Sexo;FNac\n9;Leone;Fernando;M;1958-12-24\n26;Garcia;Laura;M;1954-01-21\n35;Salamone;Nicolas;M;1993-06-27\n48;Gonzalez;Viviana;F;1965-06-21\n\n\n\n\ninfo &lt;- read_csv2(\"datos/ejemplo-datos-header.csv\", col_names = T)\n\nObservemos que dependiendo de la forma en que se encuentren los datos en el archivo (distintos separadores, cabeceras, etc), aplicamos la función correspondiente. Además cada vez que hacemos una lectura la función se encarga de analizar (parse) el tipo de dato que hay en cada columna.\n\ndatos\n\n# A tibble: 4 × 5\n     X1 X2       X3       X4    X5        \n  &lt;dbl&gt; &lt;chr&gt;    &lt;chr&gt;    &lt;chr&gt; &lt;date&gt;    \n1     9 Leone    Fernando M     1958-12-24\n2    26 Garcia   Esteban  M     1954-01-21\n3    35 Salamone Nicolas  M     1993-06-27\n4    48 Gonzalez Viviana  F     1965-06-21\n\n\nEn el primer ejemplo, el archivo no tenía cabecera y por lo tanto, al importarse los datos cada variable se denominó X1, X2, X3, etc.\nOtra forma de mostrar la estructura del archivo y sus columnas es con la función glimpse():\n\nglimpse(info)\n\nRows: 4\nColumns: 5\n$ Iden     &lt;dbl&gt; 9, 26, 35, 48\n$ Apellido &lt;chr&gt; \"Leone\", \"Garcia\", \"Salamone\", \"Gonzalez\"\n$ Nombre   &lt;chr&gt; \"Fernando\", \"Laura\", \"Nicolas\", \"Viviana\"\n$ Sexo     &lt;chr&gt; \"M\", \"M\", \"M\", \"F\"\n$ FNac     &lt;date&gt; 1958-12-24, 1954-01-21, 1993-06-27, 1965-06-21\n\n\nLos posibles tipos de datos son los atómicos del lenguaje más algún agregado: character, integer, numeric, double, logical y date/time.\nPor ejemplo, en la tabla leída anteriormente las columnas donde hay números enteros fueron reconocidos como double (&lt;dbl&gt;), los que tienen algún caracter como character (&lt;chr&gt;) y las fechas como date (&lt;date&gt;).\nAgregamos unos argumentos más y ejemplificamos la sintaxis con read_delim() para leer un archivo con cabecera compleja (la tabla comienza en la fila 9) separado por caracteres | (pipes).\n\nread_delim(\"ejemplo-datos-header-skip.txt\", \n           col_names = T, \n           skip = 8, \n           delim = \"|\")\n\n\nCuando realicemos lecturas no debemos olvidar asignar su salida a un nombre, que será el nombre del dataframe que reciba los datos dentro de nuestra sesión de trabajo. (&lt;-)\n\n\nFunciones de escritura\nDentro del paquete coexisten funciones espejo de escritura para las posibilidades de lectura más relevantes. Así encontramos estos cuatro:\n\nwrite_csv(): escribe archivos separados por comas (csv)\nwrite_csv2(): escribe archivos separados por punto y comas (csv)\nwrite_tsv(): escribe archivos separados por tabulaciones\nwrite_delim(): escribe archivos separados con delimitadores definidos por el usuario\n\nLos argumentos son generales y para el caso del último más extensos, dado que hay que definir cual es el separador que deseamos en el archivo.\n\nargs(write_delim)\n\nfunction (x, file, delim = \" \", na = \"NA\", append = FALSE, col_names = !append, \n    quote = c(\"needed\", \"all\", \"none\"), escape = c(\"double\", \n        \"backslash\", \"none\"), eol = \"\\n\", num_threads = readr_threads(), \n    progress = show_progress(), path = deprecated(), quote_escape = deprecated()) \nNULL\n\n\nPor ejemplo para exportar un conjunto de datos en texto plano al que denominaremos “ejemplo.csv” con separador punto y coma y cabecera incluida podemos hacer:\n\nwrite_delim(x = datos, file = \"ejemplo.csv\", delim = \";\")\n\no más sencillo:\n\nwrite_csv2(datos, \"ejemplo.csv\") # define cabecera y separador ;\n\n\n\n\nPaquete readxl\nUno de los formatos de documentos más comunes en los que se almacenan datos son las hojas de cálculo, en particular, las creadas con el programa Excel de Microsoft Office.\nEl paquete readxl es parte del ecosistema tidyverse y permite leer este tipo de archivos.\nPosee compatibilidad con hojas de cálculo de Excel 97-03, de extensión .xls, y con hojas de cálculo de las versiones más recientes de Excel, de extensión, .xlsx\nLa primera función interesante es excel_sheets(), útil para conocer y listar los nombre de las hojas contenidas dentro de un archivo (libro) Excel.\nPor ejemplo, supongamos que tenemos un archivo denominado “datos.xlsx” y queremos saber por cuantas hojas está compuesto y que nombre tienen.\n\nlibrary(readxl) # hay que activarlo independientemente de tidyverse\n\nexcel_sheets(\"datos/datos.xlsx\")\n\n[1] \"diabetes\"   \"vigilancia\" \"mortalidad\"\n\n\nObtenemos de esta manera información sobre el archivo. Hay tres hojas llamadas diabetes, vigilancia y mortalidad.\nPara poder leer cada una de estas hojas de datos debemos usar la función read_excel(), que tiene los siguientes argumentos:\n\nargs(read_excel)\n\nfunction (path, sheet = NULL, range = NULL, col_names = TRUE, \n    col_types = NULL, na = \"\", trim_ws = TRUE, skip = 0, n_max = Inf, \n    guess_max = min(1000, n_max), progress = readxl_progress(), \n    .name_repair = \"unique\") \nNULL\n\n\nDonde los más relevantes son:\npath: nombre del archivo y la ubicación (si fuese necesaria) entre comillas\nsheet: nombre de la hoja o número de ubicación\ncol_names: si se activa toma la primer fila como nombres de columnas (variables)\nskip: permite saltear una cantidad determinada de filas antes de comenzar la lectura\nEn primer lugar, cuando ejecutamos esta función, llama a otra denominada excel_format() que determina frente a que formato de archivo estamos. Si es un Excel tipo .xsl o tipo .xlsx. En relación a esta respuesta, luego aplica la función específica para cada caso - read_xls() o readxlsx().\nTodas estas funciones mencionadas en el procedimiento que sigue read_excel() se pueden utilizar en forma específica.\nContinuemos con el archivo “datos.xlsx” y procedamos a leer los datos de su primer hoja, llamada diabetes.\n\ndiabetes &lt;- read_excel(path = \"datos/datos.xlsx\", \n                       sheet = \"diabetes\",\n                       col_names = T)\n\nhead(diabetes) # mostramos las 6 primeras observaciones\n\n# A tibble: 6 × 8\n    A1C  hba1 GLUCB   SOG Tol_Glucosa    DM    SM  HOMA\n  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;       &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n1  6.17   7.9   101   122 IFG             0     1  4.04\n2  5.58   7.2   103   100 IFG             0     0  5.03\n3  5.38   7.1   103    90 IFG             0     1  2.92\n4  5.38   6.6   109    96 IFG             0     1  4.79\n5  5.19   6.3   107    69 IFG             0     1  3.06\n6  4.89   6      NA   117 IFG             0     0  5.77\n\n\nObservemos que en los argumentos escribimos el nombre del archivo que se encuentra en nuestro proyecto y por lo tanto en nuestra carpeta activa, el nombre de la hoja y nos aseguramos que la primer fila representa a la cabecera de la tabla (sus nombres de variables).\nComo el paquete readxl se inscribe dentro del universo tidyverse el formato de salida es un dataframe/tibble. En este caso de 23 observaciones por 8 variables.\nAhora leamos la segunda hoja de nombre vigilancia.\n\nvigilancia &lt;- read_excel(path = \"datos/datos.xlsx\", \n                         sheet = 2, \n                         col_names = F)\n\nhead(vigilancia) # mostramos las 6 primeras observaciones\n\n# A tibble: 6 × 9\n   ...1 ...2        ...3      ...4  ...5  ...6  ...7 ...8  ...9                 \n  &lt;dbl&gt; &lt;chr&gt;      &lt;dbl&gt;     &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;                \n1   875 09/28/2015  2015 544080000     1    31     1 F     VIGILANCIA EN SALUD …\n2   875 42317       2015 544080000     1    35     1 F     VIGILANCIA EN SALUD …\n3   875 42317       2015 544080000     1    47     1 F     VIGILANCIA EN SALUD …\n4   307 09/26/2015  2015 544005273     1    23     1 M     VIGILANCIA INTEGRADA…\n5   307 09/24/2015  2015 544005273     1    19     1 M     VIGILANCIA INTEGRADA…\n6   875 09/28/2015  2015 544080000     1    63     1 F     VIGILANCIA EN SALUD …\n\n\nCentremos nuestra mirada en los argumentos anteriores: en lugar del nombre de la hoja usamos un 2 que es su ubicación (la segunda hoja del archivo Excel) y configuramos a col_names con F (false) porque el conjunto de datos no tiene cabecera.\nCuando ocurre esta situación donde la tabla no tiene nombre de columnas readxl le asigna nombres del tipo ...1, ...2, ...x\nFinalmente leemos la última hoja disponible del archivo.\n\nmortalidad &lt;- read_excel(path = \"datos/datos.xlsx\", \n                         sheet = \"mortalidad\",\n                         col_names = T, \n                         skip = 1)\n\nhead(mortalidad) # mostramos las 6 primeras observaciones\n\n# A tibble: 5 × 10\n  grupo_edad grupo.I.1.1 grupo.II.1.1 grupo.III.1.1 grupo.I.2.1 grupo.II.2.1\n  &lt;chr&gt;            &lt;dbl&gt;        &lt;dbl&gt;         &lt;dbl&gt;       &lt;dbl&gt;        &lt;dbl&gt;\n1 30-44               41          202           222         539         1438\n2 45-59               99         1071           181         759         6210\n3 60-69              114         1782           119         985         9238\n4 70-79              221         2336           119        1571        12369\n5 80+                362         2492            81        2523        14642\n# ℹ 4 more variables: grupo.III.2.1 &lt;dbl&gt;, grupo.I.3.1 &lt;dbl&gt;,\n#   grupo.II.3.1 &lt;dbl&gt;, grupo.III.3.1 &lt;dbl&gt;\n\n\nLo novedoso de esta lectura es el argumento skip = 1 que debimos incorporar dado que, en este caso, la hoja de Excel comienza con una línea de título que no pertenece al conjunto de datos. También que el argumento sheet permite el nombre de la hoja elegida entre comillas.\nRetomando los argumentos generales de la función podemos mencionar estos otros:\nn_max: número máximo de filas leídas\nrange: rango de celdas a leer (definidas como se suele usar en Excel, por ej: B3:D87)\ncol_types: especificación del tipo de dato para cada columna leída. Se pueden utilizar los tipos habituales “numeric”, “logical”, “text”, “date”, etc. Existen dos tipos específicos más: “skip” que saltea la lectura de la columna y “guess” que permite que la función decida cual es el formato adecuado de importación. Este último es el modo predeterminado cuando no especificamos el argumento.\nna: caracter o vector que deseamos se interprete como valor perdido (missing). Por defecto las celdas vacías se interpretan de esta forma y se le asigna NA",
    "crumbs": [
      "Introducción a tidyverse"
    ]
  },
  {
    "objectID": "tidyverse.html#gestión-de-datos-con-el-paquete-dplyr",
    "href": "tidyverse.html#gestión-de-datos-con-el-paquete-dplyr",
    "title": "Introducción a tidyverse",
    "section": "Gestión de datos con el Paquete dplyr",
    "text": "Gestión de datos con el Paquete dplyr\nEl paquete dplyr es parte del universo tidyverse que fue desarrollado por Hadley Wickham a partir de optimizar una versión del paquete plyr.\nLa contribución significativa del paquete es proporcionar una “gramática” (funciones-verbos) para la manipulación y operaciones de datos que lo hace más fácil de entender.\nLas funciones clave del paquete, responden a las siguientes acciones (verbos):\n\nselect(): devuelve un conjunto de columnas (variables)\nrename(): renombra variables en una conjunto de datos\nfilter(): devuelve un conjunto de filas (observaciones) según una o varias condiciones lógicas\narrange(): reordena filas de un conjunto de datos\nmutate(): añade nuevas variables/columnas o transforma variables existentes\nsummarise()/summarize(): genera resúmenes estadísticos de diferentes variables en el conjunto de datos.\ngroup_by(): agrupa un conjunto de filas seleccionado, en un conjunto de filas de resumen de acuerdo con los valores de una o más columnas o expresiones.\ncount(): contabiliza valores que se repiten, es decir genera tabla de frecuencias.\n\nAdemás como todos los paquetes del tidyverse integra al operador %&gt;% (pipe) logrando una única tubería (“pipeline”).\n\nArgumentos comúnes en las funciones dplyr\nTodas las funciones, básicamente, tienen en común una serie de argumentos.\n\nEl primer argumento es el nombre del conjunto de datos (objeto donde esta nuestra tabla de datos).\nLos otros argumentos describen que hacer con el conjunto de datos especificado en el primer argumento, podemos referirnos a las columnas en el objeto directamente sin utilizar el operador $, es decir sólo con el nombre de la columna/variable.\nEl valor de retorno es un nuevo conjunto de datos.\nLos conjuntos de datos deben estar bien organizados/estructurados, es decir debe existir una observación por columna y, cada columna representar una variable, medida o característica de esa observación. Es decir, debe cumplir con tidy data.\n\n\n\nActivación del paquete\ndplyr está incluído en el paquete tidyverse, por lo que se encuentra disponible si tenemos activado a este último.\nTambién se puede activar en forma independiente, aunque no es necesario si ya activamos tidyverse:\n\nlibrary(dplyr)\n\n\n\nConjunto de datos para ejemplo\nVisualizar y entender el funcionamiento de estos “verbos” de manipulación es posible si ejemplificamos su aplicación. Por este motivo vamos a leer un conjunto de datos que servirá para ejercitar las funciones del paquete.\n\ndatos &lt;- read_csv(\"datos/noti-vih.csv\") # asignamos la lectura a datos\n\nhead(datos) # mostramos las 6 primeras observaciones\n\n# A tibble: 6 × 4\n  jurisdiccion   año casos      pob\n  &lt;chr&gt;        &lt;dbl&gt; &lt;dbl&gt;    &lt;dbl&gt;\n1 Buenos Aires  2015  1513 16626374\n2 Buenos Aires  2016   957 16789474\n3 CABA          2015   901  3054237\n4 CABA          2016   427  3050000\n5 Catamarca     2015    69   396552\n6 Catamarca     2016    51   401575\n\n\nLa tabla de datos “noti-vih.csv” contiene datos de notificación de vih por jurisdicción de Argentina para los años 2015 y 2016.\n\n\nFunción select()\nEsta función selecciona las variables que especificamos devolviendo un conjunto de datos “recortado por columna”.\nVeamos algunas variaciones de ayuda para hacer estas selecciones.\nTodas las variables menos pob\n\ndatos |&gt; \n  select(-pob)\n\n# A tibble: 48 × 3\n   jurisdiccion   año casos\n   &lt;chr&gt;        &lt;dbl&gt; &lt;dbl&gt;\n 1 Buenos Aires  2015  1513\n 2 Buenos Aires  2016   957\n 3 CABA          2015   901\n 4 CABA          2016   427\n 5 Catamarca     2015    69\n 6 Catamarca     2016    51\n 7 Chaco         2015    15\n 8 Chaco         2016     9\n 9 Chubut        2015   110\n10 Chubut        2016    89\n# ℹ 38 more rows\n\n\nOtra forma para el mismo resultado anterior (mediante el operador rango :)\n\ndatos |&gt; \n  select(jurisdiccion:casos)\n\n# A tibble: 48 × 3\n   jurisdiccion   año casos\n   &lt;chr&gt;        &lt;dbl&gt; &lt;dbl&gt;\n 1 Buenos Aires  2015  1513\n 2 Buenos Aires  2016   957\n 3 CABA          2015   901\n 4 CABA          2016   427\n 5 Catamarca     2015    69\n 6 Catamarca     2016    51\n 7 Chaco         2015    15\n 8 Chaco         2016     9\n 9 Chubut        2015   110\n10 Chubut        2016    89\n# ℹ 38 more rows\n\n\nLas variables jurisdiccion y casos\n\ndatos |&gt; \n  select(jurisdiccion, casos)\n\n# A tibble: 48 × 2\n   jurisdiccion casos\n   &lt;chr&gt;        &lt;dbl&gt;\n 1 Buenos Aires  1513\n 2 Buenos Aires   957\n 3 CABA           901\n 4 CABA           427\n 5 Catamarca       69\n 6 Catamarca       51\n 7 Chaco           15\n 8 Chaco            9\n 9 Chubut         110\n10 Chubut          89\n# ℹ 38 more rows\n\n\nOtra forma para el mismo resultado anterior (mediante números de columna):\n\ndatos |&gt; \n  select(1, 3)\n\n# A tibble: 48 × 2\n   jurisdiccion casos\n   &lt;chr&gt;        &lt;dbl&gt;\n 1 Buenos Aires  1513\n 2 Buenos Aires   957\n 3 CABA           901\n 4 CABA           427\n 5 Catamarca       69\n 6 Catamarca       51\n 7 Chaco           15\n 8 Chaco            9\n 9 Chubut         110\n10 Chubut          89\n# ℹ 38 more rows\n\n\nTodas las variables pasando año a la primera columna\n\ndatos |&gt; \n  select(\"año\", everything())\n\n# A tibble: 48 × 4\n     año jurisdiccion casos      pob\n   &lt;dbl&gt; &lt;chr&gt;        &lt;dbl&gt;    &lt;dbl&gt;\n 1  2015 Buenos Aires  1513 16626374\n 2  2016 Buenos Aires   957 16789474\n 3  2015 CABA           901  3054237\n 4  2016 CABA           427  3050000\n 5  2015 Catamarca       69   396552\n 6  2016 Catamarca       51   401575\n 7  2015 Chaco           15  1153846\n 8  2016 Chaco            9  1125000\n 9  2015 Chubut         110   567010\n10  2016 Chubut          89   577922\n# ℹ 38 more rows\n\n\nOtros posibles argumentos son:\n\nstarts_with(): selecciona todas las columnas que comiencen con el patrón indicado.\nends_with(): selecciona todas las columnas que terminen con el patrón indicado.\ncontains(): selecciona las columnas que posean el patrón indicado.\nmatches(): similar a contains(), pero permite poner una expresión regular.\nall_of(): selecciona las variables pasadas en un vector (todos los nombres deben estar presentes o devuelve un error)\nany_of(): idem anterior excepto que no se genera ningún error para los nombres que no existen.\nnum_range(): selecciona variables con nombre combinados con caracteres y números (ejemplo: num_range(“x”, 1:3) selecciona las variables x1, x2 y x3.\nwhere(): aplica una función a todas las variables y selecciona aquellas para las cuales la función regresa TRUE (por ejemplo: is.numeric() para seleccionar todas las variables numéricas)\n\n\n\nFunción rename()\nEsta función es una extensión de select(), dado que esta última permite cambiar el nombre de variables pero no es muy útil porque descarta todas las variables que no se mencionan explícitamente. En cambio rename() renombra variables mientras que mantiene las demás no mencionadas.\nPor ejemplo, cambiamos el nombre de la variable pob por población.\n\ndatos |&gt;\n  rename(\"población\" = pob)\n\n# A tibble: 48 × 4\n   jurisdiccion   año casos población\n   &lt;chr&gt;        &lt;dbl&gt; &lt;dbl&gt;     &lt;dbl&gt;\n 1 Buenos Aires  2015  1513  16626374\n 2 Buenos Aires  2016   957  16789474\n 3 CABA          2015   901   3054237\n 4 CABA          2016   427   3050000\n 5 Catamarca     2015    69    396552\n 6 Catamarca     2016    51    401575\n 7 Chaco         2015    15   1153846\n 8 Chaco         2016     9   1125000\n 9 Chubut        2015   110    567010\n10 Chubut        2016    89    577922\n# ℹ 38 more rows\n\n\n\n\nFunción filter()\nAsí como la función select() es utilizada para seleccionar columnas, la función filter() hace lo propio con las filas del conjunto de datos, produciendo un subconjunto de observaciones.\nVeamos un ejemplo sencillo sobre nuestros datos:\n\ndatos |&gt;\n  filter(jurisdiccion == \"Tucuman\")\n\n# A tibble: 2 × 4\n  jurisdiccion   año casos     pob\n  &lt;chr&gt;        &lt;dbl&gt; &lt;dbl&gt;   &lt;dbl&gt;\n1 Tucuman       2015   258 1592593\n2 Tucuman       2016   246 1618421\n\n\nUtiliza los mismos operadores de comparación propios del lenguaje R\n\n\nOperadorDescripción&lt;Menor a&gt;Mayor a&lt;=Menor o igual a&gt;=Mayor o igual a==Igual a!=No igual a%in%Es parte deis.na()Es NA!is.na()No es NA\n\n\nLo mismo con los operadores lógicos que se utilizan como conectores entre las expresiones.\n\n\nOperadorDescripción&AND booleano|OR booleanoxor()OR exclusivo!NOTany()cualquier TRUEall()todos TRUE\n\n\nCuando usamos múltiples argumentos separados por coma dentro de filter() se combinan con un conector AND, es decir cada expresión debe ser verdadera para que una fila sea incluida en la salida.\nPor ejemplo:\nFiltramos a las observaciones que cumplan con la condición que casos sea mayor a 100 y población sea menor a 1000000\n\ndatos |&gt;\n  filter(casos &gt; 100, pob &lt; 1000000)\n\n# A tibble: 7 × 4\n  jurisdiccion   año casos    pob\n  &lt;chr&gt;        &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;\n1 Chubut        2015   110 567010\n2 Jujuy         2015   160 727273\n3 Jujuy         2016   133 734807\n4 Neuquen       2015   109 619318\n5 Neuquen       2016   101 627329\n6 Rio Negro     2015   112 700000\n7 Rio Negro     2016   105 709459\n\n\nPara combinaciones dentro de una misma variable debemos utilizar el conector OR (|) o más útil el operador %in%.\nFiltramos a las jurisdicciones “Buenos Aires” y “La Pampa”\n\ndatos |&gt;\n  filter(jurisdiccion == \"Buenos Aires\" | jurisdiccion == \"La Pampa\")\n\n# A tibble: 4 × 4\n  jurisdiccion   año casos      pob\n  &lt;chr&gt;        &lt;dbl&gt; &lt;dbl&gt;    &lt;dbl&gt;\n1 Buenos Aires  2015  1513 16626374\n2 Buenos Aires  2016   957 16789474\n3 La Pampa      2015    57   343373\n4 La Pampa      2016    67   345361\n\n\n\ndatos |&gt;\n  filter(jurisdiccion %in% c(\"Buenos Aires\", \"La Pampa\"))\n\n# A tibble: 4 × 4\n  jurisdiccion   año casos      pob\n  &lt;chr&gt;        &lt;dbl&gt; &lt;dbl&gt;    &lt;dbl&gt;\n1 Buenos Aires  2015  1513 16626374\n2 Buenos Aires  2016   957 16789474\n3 La Pampa      2015    57   343373\n4 La Pampa      2016    67   345361\n\n\nFiltramos las observaciones de 2016 con casos mayores a 200 utilizando el conector AND (&). Es el mismo resultado que si utilizamos una coma.\n\ndatos |&gt;\n  filter(año == \"2016\" & casos &gt; 200)\n\n# A tibble: 6 × 4\n  jurisdiccion   año casos      pob\n  &lt;chr&gt;        &lt;dbl&gt; &lt;dbl&gt;    &lt;dbl&gt;\n1 Buenos Aires  2016   957 16789474\n2 CABA          2016   427  3050000\n3 Cordoba       2016   368  3607843\n4 Mendoza       2016   254  1909774\n5 Salta         2016   230  1352941\n6 Tucuman       2016   246  1618421\n\n\nFiltramos las observaciones inversas a la anterior mediante xor(), que selecciona los valores de año y casos exclusivos (es decir que no se den ambos en TRUE).\n\ndatos |&gt; \n  filter(xor(año == \"2016\", casos &gt; 200))\n\n# A tibble: 25 × 4\n   jurisdiccion   año casos      pob\n   &lt;chr&gt;        &lt;dbl&gt; &lt;dbl&gt;    &lt;dbl&gt;\n 1 Buenos Aires  2015  1513 16626374\n 2 CABA          2015   901  3054237\n 3 Catamarca     2016    51   401575\n 4 Chaco         2016     9  1125000\n 5 Chubut        2016    89   577922\n 6 Cordoba       2015   468  3572519\n 7 Corrientes    2016    99  1076087\n 8 Entre Rios    2016   109  1329268\n 9 Formosa       2016    60   582524\n10 Jujuy         2016   133   734807\n# ℹ 15 more rows\n\n\n\n\nFunción arrange()\nLa función arrange() se utiliza para ordenar las filas de un conjunto de datos de acuerdo a una o varias columnas/variables. Por defecto, el ordenamiento es ascendente alfanumérico.\nOrdenamos la tabla datos por la variable pob (forma ascendente predeterminada):\n\ndatos |&gt;\n  arrange(pob)\n\n# A tibble: 48 × 4\n   jurisdiccion       año casos    pob\n   &lt;chr&gt;            &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;\n 1 Tierra del Fuego  2015    36 152542\n 2 Tierra del Fuego  2016    34 156682\n 3 Santa Cruz        2015    65 320197\n 4 Santa Cruz        2016    59 329609\n 5 La Pampa          2015    57 343373\n 6 La Pampa          2016    67 345361\n 7 La Rioja          2015    41 369369\n 8 La Rioja          2016     6 375000\n 9 Catamarca         2015    69 396552\n10 Catamarca         2016    51 401575\n# ℹ 38 more rows\n\n\nPara ordenar en forma descendente podemos utilizar desc() dentro de los argumentos de arrange():\n\ndatos |&gt;\n  arrange(desc(pob))\n\n# A tibble: 48 × 4\n   jurisdiccion   año casos      pob\n   &lt;chr&gt;        &lt;dbl&gt; &lt;dbl&gt;    &lt;dbl&gt;\n 1 Buenos Aires  2016   957 16789474\n 2 Buenos Aires  2015  1513 16626374\n 3 Cordoba       2016   368  3607843\n 4 Cordoba       2015   468  3572519\n 5 Santa Fe      2016   170  3400000\n 6 Santa Fe      2015   301  3382022\n 7 CABA          2015   901  3054237\n 8 CABA          2016   427  3050000\n 9 Mendoza       2016   254  1909774\n10 Mendoza       2015   316  1880952\n# ℹ 38 more rows\n\n\nPodemos combinar ordenamientos. Por ejemplo, en forma alfabética ascendente para jusrisdiccion y luego numérica descendente para casos.\n\ndatos |&gt;\n  arrange(jurisdiccion, desc(casos))\n\n# A tibble: 48 × 4\n   jurisdiccion   año casos      pob\n   &lt;chr&gt;        &lt;dbl&gt; &lt;dbl&gt;    &lt;dbl&gt;\n 1 Buenos Aires  2015  1513 16626374\n 2 Buenos Aires  2016   957 16789474\n 3 CABA          2015   901  3054237\n 4 CABA          2016   427  3050000\n 5 Catamarca     2015    69   396552\n 6 Catamarca     2016    51   401575\n 7 Chaco         2015    15  1153846\n 8 Chaco         2016     9  1125000\n 9 Chubut        2015   110   567010\n10 Chubut        2016    89   577922\n# ℹ 38 more rows\n\n\n\n\nFunción mutate()\nEsta función nos proporciona computar tranformaciones de variables en un conjunto de datos. A menudo, tendremos la necesidad de modificar variables existentes o crear nuevas variables que se calculan a partir de las que tenemos, mutate() nos ofrece una interface clara para realizar este tipo de operaciones.\nPor ejemplo, nos puede interesar calcular tasas crudas para cada jurisdicción y año, en función de los casos y el total de población.\n\ndatos |&gt;\n  mutate(tasa = casos/pob*100000)\n\n# A tibble: 48 × 5\n   jurisdiccion   año casos      pob  tasa\n   &lt;chr&gt;        &lt;dbl&gt; &lt;dbl&gt;    &lt;dbl&gt; &lt;dbl&gt;\n 1 Buenos Aires  2015  1513 16626374  9.10\n 2 Buenos Aires  2016   957 16789474  5.70\n 3 CABA          2015   901  3054237 29.5 \n 4 CABA          2016   427  3050000 14   \n 5 Catamarca     2015    69   396552 17.4 \n 6 Catamarca     2016    51   401575 12.7 \n 7 Chaco         2015    15  1153846  1.30\n 8 Chaco         2016     9  1125000  0.8 \n 9 Chubut        2015   110   567010 19.4 \n10 Chubut        2016    89   577922 15.4 \n# ℹ 38 more rows\n\n\nObservemos que la función realiza el cálculo (en este caso tasas crudas por 100000 habitantes) e incorpora una nueva variable por cada observación con el resultado.\nTambién se pueden construir múltiples variables en la misma expresión, solamente separadas por comas.\n\ndatos |&gt;\n  mutate(tasaxcien_mil = casos/pob*100000, \n         tasaxdiez_mil = casos/pob*10000)\n\n# A tibble: 48 × 6\n   jurisdiccion   año casos      pob tasaxcien_mil tasaxdiez_mil\n   &lt;chr&gt;        &lt;dbl&gt; &lt;dbl&gt;    &lt;dbl&gt;         &lt;dbl&gt;         &lt;dbl&gt;\n 1 Buenos Aires  2015  1513 16626374          9.10         0.910\n 2 Buenos Aires  2016   957 16789474          5.70         0.570\n 3 CABA          2015   901  3054237         29.5          2.95 \n 4 CABA          2016   427  3050000         14            1.4  \n 5 Catamarca     2015    69   396552         17.4          1.74 \n 6 Catamarca     2016    51   401575         12.7          1.27 \n 7 Chaco         2015    15  1153846          1.30         0.130\n 8 Chaco         2016     9  1125000          0.8          0.08 \n 9 Chubut        2015   110   567010         19.4          1.94 \n10 Chubut        2016    89   577922         15.4          1.54 \n# ℹ 38 more rows\n\n\nSi necesitemos que estas dos nuevas variables queden dentro de la tabla de datos y no solo mostrarla en consola como hasta ahora, debemos utilizar el operador de asignación:\n\ndatos &lt;- datos |&gt;\n  mutate(tasaxcien_mil = casos/pob*100000, \n         tasaxdiez_mil = casos/pob*10000)\n\nLa propiedad imprescindible es que la función debe poder vectorizar: debe tomar un vector de valores como entrada, y devolver un vector con el mismo número de valores que la salida.\nNo hay forma de enumerar todas las funciones posibles que se podría usar, pero mencionaremos algunas que pueden ser útiles:\n\nOperadores aritméticos: +, -, *, /, ^.\nAritmética modular: %/% (división entera) y %% (resto), donde \\(x == y * (x \\ \\%/\\% \\ y) + (x\\ \\%\\% \\ y)\\). La aritmética modular es una herramienta útil porque te permite dividir números enteros en porciones.\nFunciones matemáticas: log(), log2(), log10(), exp(), sqrt(), abs(), etc\nValores acumulados: R proporciona funciones para ejecutar sumas, productos, mínimos y máximos acumulados: cumsum(), cumprod(), cummin(), cummax(); y dplyr proporciona cummean() para promedios acumulados.\nClasificaciones (ranking): hay una serie de funciones de clasificación, por ejemplo min_rank(). Genera el tipo de clasificación habitual (1º, 2º, etc). El valor predeterminado relaciona los valores más pequeños a rangos pequeños; podemos usar desc(x) para invertir la relación (valores más grandes a rangos más pequeños)\n\nSi utilizamos el mismo nombre de una variable incluída dentro de la tabla de datos, estaremos sobrescribiendola (se usa cuando transformamos una variable, por ejemplo: le cambiamos su tipo de character a factor). Para que la variable sea nueva debe nombrarse con un nombre que no exista previamente dentro de la tabla de datos.\n\n\nFunción summarise()\nLa función summarise() (se puede escribir también summarize()) resume variables de un conjunto de datos.\n\ndatos |&gt;\n  summarise(promedio_casos = mean(casos), \n            casos_totales = sum(casos))\n\n# A tibble: 1 × 2\n  promedio_casos casos_totales\n           &lt;dbl&gt;         &lt;dbl&gt;\n1           192.          9211\n\n\nSu uso es muy interesante cuando la combinamos con group_by() (función que detallaremos luego). Esta situación permite estratificar los resultados por grupos específicos.\nPor ejemplo, podemos agrupar el por año y simultáneamente aplicar el mismo summarise() anterior.\n\ndatos |&gt; \n  group_by(año) |&gt; \n  summarise(promedio_casos = mean(casos), \n            casos_totales = sum(casos))\n\n# A tibble: 2 × 3\n    año promedio_casos casos_totales\n  &lt;dbl&gt;          &lt;dbl&gt;         &lt;dbl&gt;\n1  2015           224.          5369\n2  2016           160.          3842\n\n\nEl resultado es una tabla con dos filas, una para cada grupo (año 2015 y año 2016) con los valores promedio y casos totales respectivos.\nAlgunas de las funciones del R base que se pueden utilizar dentro de los argumentos de esta función son:\n\nmin(): mínimo\nmax(): máximo\nmean(): media\nmedian(): mediana\nvar(): varianza\nsd(): desvío\nsum(): sumatoria\n\nOtras funciones que se pueden incorporar las provee el mismo paquete dplyr, por ejemplo:\n\nfirst(): primer valor en el vector\nlast(): último valor en el vector\nn(): número de valores en el vector\nn_distinct(): números de valores distintos en el vector\n\n\n\nFunción group_by()\nDecíamos recién que la función group_by() es útil cuando trabaja conjuntamente con summarise() dado que agrupa un conjunto de filas seleccionado en un conjunto de filas de resumen de acuerdo con los valores de una o más columnas o expresiones.\nPara ejemplificar su trabajo asociado obtendremos una nueva tabla con el cálculo de las tasas crudas para cada jurisdicción por año (similar al ejemplo de la aplicación de mutate():\n\ndatos |&gt;\n  group_by(jurisdiccion, año) |&gt; \n  summarise(tasa = casos/pob*100000)\n\n# A tibble: 48 × 3\n# Groups:   jurisdiccion [24]\n   jurisdiccion   año  tasa\n   &lt;chr&gt;        &lt;dbl&gt; &lt;dbl&gt;\n 1 Buenos Aires  2015  9.10\n 2 Buenos Aires  2016  5.70\n 3 CABA          2015 29.5 \n 4 CABA          2016 14   \n 5 Catamarca     2015 17.4 \n 6 Catamarca     2016 12.7 \n 7 Chaco         2015  1.30\n 8 Chaco         2016  0.8 \n 9 Chubut        2015 19.4 \n10 Chubut        2016 15.4 \n# ℹ 38 more rows\n\n\nEn la mayoría de estos ejemplos la salida es directa, es decir no construimos nuevos objetos contenedores de los datos producidos. Pero en muchas situaciones vamos a necesitar generar nuevos conjunto de datos con las transformaciones realizadas. Si en alguna de estas ocasiones llegamos a agrupar datos mediante group_by() y posteriormente necesitamos volver a tener la información desagrupada existe una función vinculada denominada ungroup()\n\n\nCombinaciones\nEn los ejemplos anteriores vimos como se van integrando alguna de las funciones mediante el uso de la tubería %&gt;% o |&gt;. La idea detrás de la búsqueda gramatical del paquete es poder enlazar las acciones para construir oraciones más complejas.\nUn ejemplo que podría integrar gran parte de los visto sería:\nObtener una nueva tabla con las tasas crudas de casos notificados de VIH, por año y jurisdicción, mayores a 20 x 100000 habitantes ordenadas de mayor a menor.\n\ndatos |&gt;                                  # siempre partimos de los datos\n  group_by(año, jurisdiccion) |&gt;          # agrupamos\n  summarise(tasa = casos/pob*100000) |&gt;   # resumimos\n  filter(tasa &gt; 20) |&gt;                    # filtramos\n  arrange(desc(tasa))                       # ordenamos   \n\n# A tibble: 5 × 3\n# Groups:   año [2]\n    año jurisdiccion      tasa\n  &lt;dbl&gt; &lt;chr&gt;            &lt;dbl&gt;\n1  2015 CABA              29.5\n2  2015 Tierra del Fuego  23.6\n3  2015 Jujuy             22.0\n4  2016 Tierra del Fuego  21.7\n5  2015 Santa Cruz        20.3\n\n\nObservemos que una buena manera de construir el código es respetar un salto de línea para cada término de la oración para una lectura más clara.\nDemostramos así la potencialidad que tienen estas funciones combinadas donde en esta situación integramos las funciones group_by(), summarise() , filter() y arrange() en una misma operación.\n\n\nFunción count()\nEsta última función que presentamos permite contar rápidamente los valores únicos de una o más variables.\nProduce fácilmente tablas de frecuencias absolutas que luego posibilitan construir frecuencias relativas.\nLa aplicamos sobre la variable jurisdiccion de datos:\n\ndatos |&gt;\n  count(jurisdiccion)\n\n# A tibble: 24 × 2\n   jurisdiccion     n\n   &lt;chr&gt;        &lt;int&gt;\n 1 Buenos Aires     2\n 2 CABA             2\n 3 Catamarca        2\n 4 Chaco            2\n 5 Chubut           2\n 6 Cordoba          2\n 7 Corrientes       2\n 8 Entre Rios       2\n 9 Formosa          2\n10 Jujuy            2\n# ℹ 14 more rows\n\n\nTiene un par de argumentos opcionales:\n\nname: es el nombre de la columna con el conteo. Por defecto se llama n\nsort: ordena la tabla de frecuencia de mayor a menor\nwt: se puede opcionalmente incorporar una variable con la ponderación (factor de expansión) para el calculo de la frecuencia.",
    "crumbs": [
      "Introducción a tidyverse"
    ]
  },
  {
    "objectID": "tidyverse.html#gráficos-estadísticos-con-ggplot2",
    "href": "tidyverse.html#gráficos-estadísticos-con-ggplot2",
    "title": "Introducción a tidyverse",
    "section": "Gráficos estadísticos con ggplot2",
    "text": "Gráficos estadísticos con ggplot2\nggplot2 es un paquete que se autodefine como librería para “crear elegantes visualizaciones de datos usando una gramática de gráficos”\nPropone una forma intuitiva de construir gráficos basada en The Grammar of Graphics, a partir de utilizar capas y un sistema apoyado en tres componentes básicos:\n\ndatos\ncoordenadas\nobjetos geométricos\n\nLa estructura para construir un gráfico es la siguiente:\n\n\n\n\n\n\nAnatomía de gráficos con ggplot2\nEl paquete se basa en una gramática de gráficos que puede ser entendida a partir de conocer sus componentes:\n\n\n\n\n\n\ndata: es aquél conjunto de datos que vamos a graficar, con toda la información pertinente para realizar el gráfico.\naes(): reducción de aesthetic mapping o mapeo estético en el que se puede declarar todo lo que puede ser visible de un gráfico.\ngeoms: son representaciones para dibujar gráficos (puntos, líneas, cajas, entre otros).\nstats: son aquellas transformaciones estadísticas que le hacemos a los datos. Nos ayudan a hacer un resumen del conjunto de datos para visualizar mejor (por ejemplo, la media o la mediana como estadísticas de tendencia central).\nscales: facilitan colorear (o escalar) los datos según distintas variables. Dibujan los ejes y las leyendas.\ncoordinate systems: es el sistema de coordenadas para el mapeo del gráfico en un plano bidimensional.\nfacets: nos permiten partir el conjunto de datos según factores para graficar en viñetas separadas creando matrices gráficas.\nthemes: son conjuntos de características gráficas que permiten controlar la apariencia general de todos los elementos que no son datos (por ejemplo, el color del fondo o el tipo de fuente).\n\nAntes de comenzar a explicar cada componente vamos a leer un conjunto de datos que nos permita mostrar los ejemplos gráficos.\n\nlibrary(tidyverse)\n\nfacultad &lt;- read_csv(\"datos/facultad.csv\") # lectura\n\nhead(facultad) # mostramos las 6 primeras observaciones\n\n# A tibble: 6 × 18\n     HC SEXO   EDAD ANT_DIABETES ANT_TBC ANT_CANCER ANT_OBESIDAD ANT_ECV ANT_HT\n  &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt;        &lt;chr&gt;   &lt;chr&gt;      &lt;chr&gt;        &lt;chr&gt;   &lt;chr&gt; \n1 26880 M        17 NO           NO      NO         SI           NO      SI    \n2 26775 M        18 SI           NO      NO         NO           NO      NO    \n3 26877 M        18 SI           NO      SI         NO           NO      SI    \n4 26776 M        18 NO           NO      NO         SI           SI      NO    \n5 26718 M        18 NO           NO      NO         NO           NO      SI    \n6 26738 M        18 NO           NO      NO         NO           NO      SI    \n# ℹ 9 more variables: ANT_COL &lt;chr&gt;, FUMA &lt;chr&gt;, EDADINI &lt;dbl&gt;, CANTIDAD &lt;dbl&gt;,\n#   COL &lt;dbl&gt;, PESO &lt;dbl&gt;, TALLA &lt;dbl&gt;, SIST &lt;dbl&gt;, DIAST &lt;dbl&gt;\n\n\nEl archivo leído se llama “facultad.csv” y contiene información de salud sobre ingresantes a una facultad tales como sexo, edad, talla y peso, entre otras. (son datos ficticios con fines docentes).\n\n\nMapeo estético (aesthetic mapping) y objetos geométricos (geom)\nDecíamos que aes() hace referencia al contenido estético del gráfico. Es decir, la función le brinda indicios a ggplot2 sobre cómo dibujar los distintas líneas, formas, colores y tamaños.\nEs importante notar que aes() crea una nueva capa en relación a las variables y agrega leyendas a los gráficos. Al incorporar aes() al llamado de ggplot() estamos compartiendo la información estética en todas las capas. Si deseamos que esa información sólo esté en una de las capas, debemos usar aes() en la capa correspondiente.\nVeamos como funciona y sus diferencias:\n\nfacultad |&gt;\n  ggplot(aes(TALLA, PESO)) # solo la capa estética aes()\n\n\n\n\n\n\n\n\nEste gráfico solo contiene los ejes que especificamos (PESO y TALLA) pero no contiene los datos. Si deseamos incorporarlos agregamos una capa de puntos con geom_point() a través del símbolo +:\n\nfacultad |&gt;\n  ggplot(aes(TALLA, PESO))  + \n  geom_point()                    # agregamos la capa geométrica de puntos\n\n\n\n\n\n\n\n\nPodemos diferenciar los puntos según se traten de ingresantes mujeres y hombres, asociando el argumento color dentro de aes() con la variable SEXO:\n\nfacultad |&gt;\n  ggplot(aes(TALLA, PESO, color = SEXO)) +\n  geom_point()\n\n\n\n\n\n\n\n\nEstos gráficos también posibilitan el agregado de otra capa geométrica, por ejemplo rectas de regresión para cada grupo según sexo:\n\nfacultad |&gt;\n  ggplot(aes(TALLA, PESO, color = SEXO)) + \n  geom_point() + \n  geom_smooth(method = \"lm\")            # agregamos una segunda capa geométrica \n\n\n\n\n\n\n\n\nEsta función geom_smooth() posee distintos métodos y en este ejemplo utilizamos el de regresión lineal entre talla y peso junto a sus intervalos de confianza.\nA continuación vamos a ver que diferencias existen cuando aes() se encuentra dentro del ggplot() y cuando se ubica en otras capas de funciones como en geom_point()\nDecíamos anteriormente que al incorporar aes() al llamado de ggplot() estamos compartiendo la información estética en todas las capas.\nEntonces si quitamos aes() de allí y lo ubicamos en una capa única, esta configuración deja de afectar al conjunto del gráfico:\n\nfacultad |&gt;\n  ggplot(aes(TALLA, PESO)) + \n  geom_point(aes(color = SEXO)) + # color esta definido en el aes() \n                                  # de la capa geométrica\n  geom_smooth(method = \"lm\")\n\n\n\n\n\n\n\n\nEn este ejemplo, aes() para el color solo se ubica dentro de geom_point() y por lo tanto dibuja los puntos con sus respectivos colores, pero no afecta a la capa de geom_smooth() produciendo solo una línea de regresión para el conjunto de puntos.\nEs decir que geom_smooth() no recibe la orden de agrupar según SEXO, a raíz de no haber definido color dentro del aes() general.\nEste comportamiento nos permite gran versatilidad en los gráficos que realicemos.\nAlgunas otras funciones de geom_ son:\n\ngeom_line(): para líneas\ngeom_boxplot(): para boxplot\ngeom_histogram(): para histogramas\ngeom_density(): para curvas de densidad\ngeom_bar(): para barras\n\nEstas funciones geométricas aplicadas sobre los mismos datos definen el tipo de gráfico.\nPara ejemplificar, podemos gráficar dos variables como SEXO y TALLA generando una base a la que sumaremos capas diferentes de geom():\n\n# Gráfico de puntos\nfacultad |&gt;\n  ggplot(aes(SEXO, TALLA, color = SEXO)) + \n  geom_point()                # capa geométrica de puntos\n\n\n\n\n\n\n\n# Boxplot\nfacultad |&gt;\n  ggplot(aes(SEXO, TALLA, color = SEXO)) + \n  geom_boxplot()            # capa geométrica de boxplot\n\n\n\n\n\n\n\n# Entramado de puntos\nfacultad |&gt;\n  ggplot(aes(SEXO, TALLA, color = SEXO)) + \n  geom_jitter()               # capa geométrica jitter (entramado de puntos)\n\n\n\n\n\n\n\n# Gráfico de violín\nfacultad |&gt;\n  ggplot(aes(SEXO, TALLA, fill = SEXO)) + \n  geom_violin()            # capa geométrica de violin\n\n\n\n\n\n\n\n\nObservemos que en este último gráfico cambiamos, dentro de aes(), color por fill. Mientras que color define el color del contorno del polígono, la línea de una recta o curva y los puntos, fill define el relleno de los objetos como es el caso de los violines construidos o cualquier elemento geométrico de polígono.\n\n\nEscalas (scale)\nLas configuraciones que se pueden realizar con scale son numerosas. Entre ellas encontramos cambios de color de contorno y relleno, cambios de posición, de tamaño y tipo de línea.\nEl argumento para modificar valores de escala comienzan siempre con con scale_ (por ejemplo scale_fill_ )\nSigamos trabajando con el conjunto de datos leído para mostrar ejemplos de gráficos donde agregamos capas de escala para color de relleno:\n\nfacultad |&gt;\n  ggplot(aes(SEXO, TALLA, fill = SEXO)) + \n  geom_boxplot() +\n  scale_fill_brewer(palette = \"Oranges\")   # paleta de los naranjas\n\n\n\n\n\n\n\n\nEn este ejemplo aplicamos una capa scale_fill_brewer() con una paleta de colores (Oranges) que se vincula con el argumento fill de aes() y definen los colores del boxplot.\nLo mismo hacemos para una gama de grises mediante scale_fill_grey():\n\nfacultad |&gt;\n  ggplot(aes(SEXO, TALLA, fill = SEXO)) + \n  geom_boxplot() +\n  scale_fill_grey(start = 0.4, end = 0.8)   # paleta de los grises\n\n\n\n\n\n\n\n\nOtro uso de escalas, esta vez aplicado a los ejes, es la inversión del eje X:\n\nfacultad |&gt;\n  ggplot(aes(TALLA, PESO, color = SEXO)) +\n  geom_point() +\n  scale_x_reverse()     # escala inversa de x\n\n\n\n\n\n\n\n\nComo se observa en el gráfico la inclusión de scale_x_reverse() provoca que la escala X se invierta, quedando la TALLA ordenada de mayor a menor.\nPor último, otro ejemplo interesante es aplicado a escalas de etiquetado de ejes. Volvamos al ejemplo reciente de boxplot con relleno en escala de grises, su eje Y se dibuja predeterminado desde 130 a casi 200 cms con cortes cada 5 cms y etiquetas cada 10 cms.\nCon escalas continuas manuales de la forma scale_*_continuos() podemos personalizar el eje Y:\n\nfacultad |&gt;\n  ggplot(aes(SEXO, TALLA, fill = SEXO)) + \n  geom_boxplot() +\n  scale_fill_grey(start = 0.4, end = 0.8)   +\n  scale_y_continuous(breaks = seq(130,200,2))\n\n\n\n\n\n\n\n\nEn este caso particular definimos un eje Y con etiquetas de 2 en 2, mediante la línea scale_y_continuous(breaks = seq(130,200,2)).\n\n\nTransformaciones estadísticas (stat)\nAlgunos gráficos no requieren de transformaciones estadísticas, en cambio, otros como boxplot, histogramas, etc. poseen valores predeterminados de stat que pueden ser modificados.\nEstos valores se encuentra en forma de argumentos dentro de la función geométrica, por ejemplo para los histograma el argumento bins define la cantidad de intervalos de clase:\n\nfacultad |&gt;\n  ggplot(aes(EDAD)) +\n    geom_histogram(bins = nclass.Sturges(facultad$EDAD), fill = \"Blue\")\n\n\n\n\n\n\n\n\nVemos que el gráfico se construyó utilizando la regla de Sturges para determinar la cantidad de intervalos de clase para la variable EDAD. (función nclass.Sturges())\nOtras transformaciones estadísticas se incorporan como capas independientes, por ejemplo si queremos agregar los valores de media a los boxplot de talla según sexo construidos anteriormente:\n\nfacultad |&gt;\n  ggplot(aes(SEXO, TALLA, fill = SEXO)) + \n  geom_boxplot() +\n  scale_fill_brewer(palette = \"Greens\") +\n  stat_summary(fun = mean, color = \"darkred\", geom = \"point\", \n               shape = 18, size = 3)\n\n\n\n\n\n\n\n\nAquí la capa completa surge a partir de la función stat_summary(), con argumentos que indican que se aplique la función mean. Incluye también la definición del objeto geométrico (point) que representa el valor de media (color, forma y tamaño)\n\n\nFacetado (facet)\nCon facet es posible separar gráficos en distintas ventanas o viñetas, creando matrices de gráficos separados por grupos de datos, a partir de la estratificación, en función de diferentes categorías de una variable cualitativa.\nEste comportamiento es sumamente útil cuando tenemos más de una variable categórica o cuando deseamos utilizar color para simbolizar otra variable.\nggplot ofrece dos posibilidades de hacer el facetado:\n\nfacet_wrap() – define subgrupos a partir de los niveles de una sola variable categórica\nfacet_grid() – define subgrupos a partir del cruce de dos variables de categóricas.\n\nUna aplicación de facet_wrap() podría ser que el primer gráfico que hicimos de dispersión de puntos con las variables TALLA y PESO se visualice en dos gráficos distintos según cada categoría de SEXO:\n\nfacultad |&gt;\n  ggplot(aes(TALLA, PESO, color = SEXO)) +\n     geom_point() +\n     facet_wrap(~SEXO)\n\n\n\n\n\n\n\n\nUsamos facet_grid() para crear una matriz producto del cruce de las variables FUMA y SEXO.Dentro de la cuadrícula graficaremos histogramas de la variable PESO coloreados por SEXO:\n\nfacultad |&gt;\n  ggplot(aes(PESO, fill = SEXO)) +\n     geom_histogram(bins = nclass.Sturges(facultad$PESO)) +\n     scale_fill_brewer(palette = \"Set1\") +\n     facet_grid(SEXO ~ FUMA)\n\n\n\n\n\n\n\n\nSi observamos las 4 líneas que integran todas las capas del código de ggplot notaremos que estamos integrando varias de las funciones que fuimos mostrando.\nSe hace imposible generar todas combinaciones posibles dada la variedad y extensión de argumentos que posee el paquete. De todas formas, el objetivo de este material es entender la base de funcionamiento, es decir la estructura “gramatical” que proponen sus autores.\n\n\nSistema de coordenadas (Coordinate Systems)\nEn algunas ocasiones puede que necesitemos introducir modificaciones en el sistema de coordinadas predeterminado.\nSobre las coordenadas cartesianas iniciales se puede invertir la orientación para que, por ejemplo, las barras se dibujen horizontales:\n\nfacultad |&gt;\n  ggplot(aes(SEXO, fill = SEXO)) +\n     scale_fill_brewer(palette = \"Set2\") +\n     geom_bar() +\n     coord_flip()   # invierte disposición de ejes\n\n\n\n\n\n\n\n\n\n\nTemas (themes)\nEl paquete ofrece un conjunto reducido de temas gráficos. El tema por defecto o inicial es theme_gray() pero se puede modificar a partir de agregar una capa de tema dentro de la estructura ggplot.\nA modo de ejemplo repetimos el último gráfico con el tema blanco y negro ( theme_bw() ):\n\nfacultad |&gt;\n  ggplot(aes(SEXO, fill = SEXO)) +\n     scale_fill_brewer(palette = \"Set2\") +\n     geom_bar() +\n     coord_flip() +\n     theme_bw()  # tema blanco y negro\n\n\n\n\n\n\n\n\nOtro tema que podemos utilizar es theme_dark() que tiene un fondo gris oscuro:\n\nfacultad |&gt;\n  ggplot(aes(SEXO, fill = SEXO)) +\n     scale_fill_brewer(palette = \"Set2\") +\n     geom_bar() +\n     coord_flip() +\n     theme_dark()\n\n\n\n\n\n\n\n\nEl siguiente cuadro muestra el nombre y presentación de los temas que contiene el paquete.\n\n\n\n\n\nContinuando con cuestiones estéticas en otra capa se pueden definir etiquetas, como título, subtítulo y nombres de ejes.\nLa forma de la función con argumentos básicos es labs( x = “Etiqueta X\", y = “Etiqueta Y\", title =“Título del gráfico\", subtitle = \"Subtítulo del gráfico\")\nAdemás se utiliza la función theme() para configurar el tipo de fuente y tamaño, entre otras opciones posibles:\n\nfacultad |&gt;\n  ggplot(aes(SEXO, fill = SEXO)) +\n     scale_fill_brewer(palette = \"Set2\") +\n     geom_bar() +\n     coord_flip() +\n     labs(y = \"Cantidad\", title = \"Distribución de Sexo\") +\n     theme(plot.title=element_text(face=\"italic\", size=16)) \n\n\n\n\n\n\n\n\n\n\nPaquete esquisse\nEsquisse es un paquete que contiene una aplicación asistente para crear gráficos ggplot2 de forma interactiva. Basta con arrastrar y soltar las variables para asignarlas a diferentes estéticas.\nPodemos visualizar rápidamente los datos de acuerdo con su tipo, exportarlos en varios formatos y recuperar el código para reproducir el gráfico.\nEl paquete se instala mediante el menú Packages de RStudio o ejecutando:\n\ninstall.packages(\"esquisse\")\n\nLuego se puede acceder a la aplicación por medio del acceso Addins\n\n\n\n\n\no ejecutando en consola esquisser()\nTambién se puede agregar el nombre de la tabla de datos dentro de los paréntesis\n\nesquisser(datos)\n\nPara más información consultar en la viñeta del paquete en CRAN.",
    "crumbs": [
      "Introducción a tidyverse"
    ]
  },
  {
    "objectID": "pasos.html",
    "href": "pasos.html",
    "title": "Primeros pasos y generalidades",
    "section": "",
    "text": "Este material es parte de la Unidad 1 del curso de Epidemiología - Nivel Avanzado  © 2025 Instituto Nacional de Epidemiología “Dr. Juan H. Jara” (ANLIS) -  CC BY-NC 4.0\nUna vez instalado el software (R + RStudio + Rtools) tenemos todo lo necesario para comenzar a trabajar con el lenguaje R.\nEn este documento vamos a explicar algunos procedimientos que vamos a llevar a cabo muchas veces en practicas a lo largo del curso.\nEn principio, aunque instalamos tres programas, el único que debemos ejecutar para ponernos a trabajar es RStudio. Éste se encarga de utilizar a R como motor/interprete y a Rtools si llegamos a necesitar instalar algún paquete desarrollado en C, C++ o Fortran.",
    "crumbs": [
      "Primeros pasos y generalidades"
    ]
  },
  {
    "objectID": "pasos.html#proyectos-de-rstudio",
    "href": "pasos.html#proyectos-de-rstudio",
    "title": "Primeros pasos y generalidades",
    "section": "Proyectos de RStudio",
    "text": "Proyectos de RStudio\nLos proyectos de RStudio se utilizan para organizar todo el código, los informes, las fuentes de datos y cualquier otro archivo utilizado en un análisis.\nLa organización del trabajo en proyectos es muy útil para asegurarnos que cada vez que necesitemos importar datos, RStudio los busque dentro de la carpeta asociada al proyecto.\nCada proyecto de RStudio se vincula con una carpeta. Esa carpeta puede estar ubicada en cualquier parte del sistema de almacenamiento que deseemos (disco rígido, pendrive, disco externo, etc).\nPodemos abrir proyectos ya creados, cerrarlos y crear proyectos nuevos.\n\nCrear un nuevo proyecto de RStudio\nCreamos un nuevo proyecto de RStudio seleccionando la opción File y luego New Project… de la barra de menú en la parte superior de la pantalla de RStudio como se muestra en la siguiente figura.\n\n\n\n\n\nTambién accedemos a generar un proyecto nuevo a partir de pulsar sobre New Project… del menú desplegado en el extremo derecho superior de la interfaz de RStudio.\n\n\n\n\n\nEn cualquiera de los dos casos aparecerá un cuadro de diálogo que presenta algunas opciones para crear el nuevo proyecto de RStudio.\n\n\n\n\n\nPor lo general, seleccionaremos la primera opción, New Directory, que crea una nueva carpeta a la que deberemos colocarle un nombre. Todos los archivos de configuración aparecerán asociados a esta nueva carpeta.\nSin embargo, si ya tenemos algunos archivos de código o archivos de datos con los que deseamos trabajar, podemos elegir la segunda opción, Existing Directory. El proyecto tomará el nombre de la carpeta ya existente que seleccionemos en forma predeterminada.\nEn este curso no utilizaremos la tercera opción Version Control.\n\n\nTipos de proyectos\nPara este ejemplo, hicimos clic en New Directory para crear un proyecto nuevo.\nLa pantalla que aparece nos mostrará una lista de tipos de proyectos de RStudio.\n\n\n\n\n\nEl primero New Proyect es el que usaremos siempre en este curso.\nLas otras opciones incluyen código específico utilizado para casos de uso especial.\nPara continuar con este ejemplo, pulsamos sobre New Project accediendo a la ventana emergente.\n\n\n\n\n\nDebemos completar dos campos de la nueva ventana.\nEn Directory name hay que escribir el nombre de la nueva carpeta que también será el nombre de nuestro proyecto.\nEn Create Project as subdirectory of: podemos pulsar sobre el botón Browse… y navegar por nuestro Explorador de Archivos hasta ubicar la carpeta donde queremos que se ubique el nuevo proyecto con su nueva carpeta asociada.\nFinalmente hacemos click en el botón Create Project.\nSupongamos que nombremos a nuestro nuevo proyecto como “Practica R” y que lo generamos dentro de la carpeta Mis Documentos.\n\n\n\n\n\nEste nuevo proyecto de RStudio se almacenará en la carpeta Practica R que encontraremos en Mis Documentos.\nLos proyectos de RStudio tienen sus propios entornos, por lo que si cerramos o cambiamos de proyecto, nuestra configuración se mantendrá inalterable.\nEsto es cierto para los scripts y cualquier otra cosa que pueda necesitar para un análisis.\nEchemos un vistazo a lo que RStudio realizó.\n\n\n\n\n\nEn la figura anterior podemos ver dos cambios en la pantalla de inicio.\nEn primer lugar el panel Files (pantalla inferior derecha) apunta a la nueva carpeta Practica R y dentro de ella vemos un nuevo archivo el nombre del proyecto y la extensión Rproj. Este archivo contiene todas las configuraciones para su proyecto.\nEl otro cambio se observa en la parte superior derecha, que muestra el nombre del proyecto. Si hacemos click en él, se desplegará el menú de proyectos.\n\n\n\n\n\nDesde aquí se puede abrir y cerrar proyectos, navegar rápidamente a proyectos que se han abierto recientemente y configurar las opciones de RStudio para cada uno de ellos.\n\n\nAbrir un proyecto existente\nCuando el proyecto ya existe, sea porque lo creamos nosotros o porque alguien nos pasó una carpeta con un proyecto de RStudio creado vamos a visualizar dentro de esa carpeta un archivo con extensión .Rproj\nLa forma más veloz para abrir el proyecto es ejecutar este archivo (debería abrir una sesión de RStudio con el proyecto activo). La otra forma es desde el menú superior derecho de RStudio en la opción Open proyect… y luego buscando en nuestro directorio el mismo archivo .Rproj.\nNota: El menú de proyectos del área superior derecha va guardando como elementos recientes los proyectos que se van abriendo y también es una forma rápida de acceder a ellos pulsando sobre estos atajos.",
    "crumbs": [
      "Primeros pasos y generalidades"
    ]
  },
  {
    "objectID": "pasos.html#scripts",
    "href": "pasos.html#scripts",
    "title": "Primeros pasos y generalidades",
    "section": "Scripts",
    "text": "Scripts\nUn script es un archivo de código que contiene un listado secuencial de funciones para ser ejecutadas en R. Estos archivos permiten guardar el código que vamos creando y volver a utilizarlo tantas veces como se quiera, además de poder compartirlo con otras personas.\n\nCómo creamos un script nuevo en RStudio?\nTenemos dos formas de crear un script nuevo. Desde el menú superior pulsando File &gt; New File &gt; R Script (atajo Ctrl+Shift+N) o con el ícono del documento con un símbolo +, como se muestra debajo.\n\n\n\n\n\n\n\nCómo ejecutamos un script en RStudio?\nLa forma de ejecutar habitualmente estos script, es línea por línea mediante el uso de la combinación de teclas Ctrl+Enter o el botón Run del editor de código de RStudio. Para esto tenemos que tener el cursor activo en la línea que queremos correr (puede ser en cualquier parte de la línea) y luego de ser ejecutada el cursor saltará automáticamente a la siguiente línea que tenga código.\nMientras ejecutamos cada línea debemos ir observando la salida en la consola y también los cambios que se dan en el bloque Environment (Entorno) donde aparecerán los objetos que vayamos creando y manipulando.\n\n\nCómo editamos un script en RStudio?\nSi queremos modificar o incorporar alguna línea al script que ya se encuentra escrita podemos hacerlo de forma directa en el editor de código.\nCada vez que hacemos un cambio debemos volver a ejecutar esa o esas líneas para que se realice la modificación.\nPodemos probar y volver a modificar tantas veces queramos pero debemos tener presente que cada manipulación en los objetos se mantiene hasta que se vuelvan a cambiar y a veces, cuando los objetos están vinculados con otras líneas de código posteriores tenemos que tener cuidado que se mantenga la coherencia.\nPor ejemplo, si tenemos un objeto vector con contenido numérico para posteriormente realizar cálculos matemáticos y nosotros cambiamos el contenido del vector por un valor caracter, ya no vamos a poder hacer los cálculos posteriores y RStudio nos informará el error en consola.\nAllí es importante tener presente el bloque Environment que nos va a mostrar siempre el contenido de cada objeto definido en memoria, para evitar operaciones incoherentes y errores.\n\n\nCómo guardamos un script en RStudio?\nCualquier agregado o modificación que hayamos realizado al script que nos interese mantener nos obligará a guardar el archivo de código editado.\nBasta con pulsar sobre el ícono del diskette celeste del editor de código para guardar el script, o bien hacerlo desde el menú principal File &gt; Save o presionando Ctrl+S.\nSi en cambio quisiera guardarlo como otro archivo para mantener el script original, podemos guardarlo con diferente nombre o en otra ubicación mediante File &gt; Save As…\n\n\nCómo abrimos un script en RStudio?\nLos scripts que construyamos o bien que nos compartan siempre tendrán extensión .R y generalmente, se encontrarán dentro de algún proyecto.\nPara abrir estos archivos .R podemos pulsar sobre ellos dentro del panel Files (abajo a la derecha) o bien desde el menú con File &gt; Open file… (atajo de teclado Ctrl+O)\nVisualizaremos el script en una nueva pestaña en el editor de código.\nEn el curso vamos a incluir a nuestros scripts dentro de algún proyecto para facilitar el trabajo, por lo que en general seguiremos la siguiente secuencia:\n\nDescargamos desde el aula virtual un archivo comprimido conteniendo la carpeta, el proyecto, el/los script/s y el/los archivos de datos.\nDescomprimimos el archivo descargado en la ubicación que deseamos (se recomienda organizar alguna carpeta destinada al curso)\nAbrimos la carpeta descomprimida y ejecutamos el archivo de proyecto .Rproj\nAl abrirse RStudio con el proyecto activo veremos en el panel Files el contenido de la carpeta. Buscamos el o los scripts (archivos con extensión .R)\nEjecutamos cada línea del script leyendo la documentación y su salida en cada caso.",
    "crumbs": [
      "Primeros pasos y generalidades"
    ]
  },
  {
    "objectID": "pasos.html#herramientas-de-rstudio",
    "href": "pasos.html#herramientas-de-rstudio",
    "title": "Primeros pasos y generalidades",
    "section": "Herramientas de RStudio",
    "text": "Herramientas de RStudio\nAlgunas de las ventajas de utilizar Rstudio son las herramientas especiales de la interfaz del editor de código\n\nAsistente de código\nCuando escribimos desde el teclado en el editor de código o en la consola de RStudio tenemos una tecla que nos autocompleta el nombre de las funciones que vamos tipeando.\nEsta herramienta de autocompletado se ejecuta pulsando la tecla de tabulación (Tab) y nos muestra las posibilidades de finalizar las palabras que vamos escribiendo junto al esquema de argumentos obligatorios que tiene asociado dicha función.\n\n\n\n\n\nAl sistematizar la escritura de código apoyándonos en el uso del autocompletado vamos a reducir la tasa de error de sintaxis, dado que las funciones, los argumentos y los nombres de las tablas y variables de nuestros datos van a estar correctamente escritos.\n\n\nAyuda en línea\nSi necesitamos acceder a una ayuda adicional en línea bastará que presionemos la tecla F1 con el cursor situado sobre el nombre de la función escrita en el editor de código para que aparezca la información relacionada en el bloque Help de Rstudio (generalmente panel abajo a la derecha).\n\n\n\n\n\n\n\nHistorial de funciones\nOtra característica de utilidad dentro de la Consola de RStudio es que si nos situamos en el prompt activo, y pulsamos las teclas flecha hacia arriba o abajo, veremos pasar la lista completa de código ejecutado en la sesión de trabajo.\nEsto nos ayuda a la hora de volver a ejecutar una función o bien cuando debemos hacer alguna corrección de la o las líneas anteriores, puesto que nos ahorra tiempo y trabajo evitando volver a tener que tipear lo que ya escribimos.\nEste historial de funciones también lo encontramos en el bloque superior derecho de RStudio, dentro de la pestaña History.\nHistory almacena todos las funciones ejecutados en consola de forma acumulativa, incluso anidando sesión tras sesión.\nLos comandos que aparecen en ese panel se pueden copiar y pegar en la Consola o, de forma más directa, puedes seleccionar uno de ellos con el mouse, y pulsar en el botón To Console (Enter) para insertarlo en consola o To Source (Shitft+Enter) para insertarlo en el script activo en el que estemos trabajando.\n\n\n\n\n\n\n\nAtajos de teclados relevantes (para Windows)\n\n\nMenúDescripciónArchivo (File)Ctrl + Shift + NCrea un nuevo scriptCtrl + OAbre un script guardadoCtrl + SGuarda el script activoCtrl + WCierra el script activoCtrl + QSale del programa RStudioEdición (Edit)Ctrl + FAbre la ventana de búsqueda (para buscar palabras dentro de un script)Ctrl + LLimpia la consolaCódigo (Code)Ctrl + EnterEjecuta la línea de código donde está situado el cursorCtrl + Alt + REjecuta todo el código del script activoCtrl + Shift + NInserta nueva sección de códigoSesión (Session)Ctrl + Shift + HAbre la ventana para establecer directorio de trabajoCtrl + Shift + F10Reinicia la sesión de RHerramientas (Tools)Alt + Shift + KAbre la lista de ayuda de atajos de teclado",
    "crumbs": [
      "Primeros pasos y generalidades"
    ]
  },
  {
    "objectID": "pasos.html#paquetes-librerías",
    "href": "pasos.html#paquetes-librerías",
    "title": "Primeros pasos y generalidades",
    "section": "Paquetes (librerías)",
    "text": "Paquetes (librerías)\nR consta de un sistema base y de librerías adicionales, llamados paquetes (packages) que extienden su funcionalidad.\nSiendo open source cualquier persona puede construir paquetes con nuevas funciones, aunque no todos se publican en el repositorio CRAN (Comprehensive R Archive Network).\nUn grupo de paquetes conforman el sistema base que quedan activos cuando instalamos el software R.\nOtro grupo de paquetes recomendados forman parte de la distribución, y si bien no quedan activos automáticamente, si se pueden activar en forma manual por el usuario.\nPor último existe otro grupo de paquetes que se encuentran publicados en el repositorio para ser descargados cuando sea necesario. Actualmente existen más de 17000 paquetes para múltiples aplicaciones.\nUna de las fortalezas de R es justamente que el listado de paquetes se va ampliando constantemente mes a mes y esto incrementa las capacidades del programa.\nExisten dos formas de descargar estos paquetes, directamente desde RStudio/R y por medio del sitio web, descargándolos como archivos comprimidos .zip\nSi el equipo se encuentra conectado a Internet es más cómodo realizar las descargas desde RStudio, pero en el caso de no tener acceso permanente a la red, se pueden descargar desde la web en otro equipo y luego guardar en el equipo donde tenemos el programa R.\nEl sitio web para las descargas de los paquetes publicados es https://cran.r-project.org/web/packages/\nAllí se encuentran los enlaces para ver el listado de paquetes ordenados alfabéticamente o por fecha de publicación.\nUna vez que ingresamos al link del paquete que nos interesa veremos en la página algunos datos relacionados como un breve texto de que trata el paquete, el numero de versión, la fecha de publicación, el autor, el archivo de documentación, y por supuesto los archivos a descargar para cada sistema operativo.\nAfortunadamente en la actualidad la mayoría de las computadoras cuentan con acceso a Internet por lo cual explicaremos como se puede descargar, instalar y activar los paquetes desde RStudio.\nRStudio tiene una pestaña específica para gestionar los paquetes ubicada de forma predeterminada en el bloque inferior derecho de la interfaz (Packages).\n\n\n\n\n\nPrácticamente todos las acciones que nos facilita la interfaz de RStudio se traduce internamente en ejecuciones de funciones de R que podemos ver en la consola.\nLa secuencia para instalar un paquete que no tengamos previamente instalado inicia a partir de pulsar el botón Install y la ventana emergente que visualizaremos es la siguiente:\n\n\n\n\n\n\nDependencias\nLa gran mayoría de las funciones que integran los paquetes que podemos descargar y utilizar están construidas en el mismo lenguaje R y para su elaboración se usan muchas veces funciones pertenecientes a otros paquetes.\nQue pasa cuando queremos ejecutar una función que necesita de otra que no tenemos instalada? Sucede que no es posible ejecutarla dado que no puede encontrar la o las funciones que están siendo llamadas en su propio código y no existen en la actual instalación de R; por lo tanto nos devolverá un mensaje de error alertando por la función desconocida.\nEsta relación de funciones que llaman a otras funciones se denomina dependencia. Es decir, que un paquete puede depender de otro u otros que tienen funciones que son llamadas y por ende, debe asegurarse su previa instalación para evitar el error.\nHay una forma de asegurarnos cuando instalamos un paquete que a su vez se instalen los paquetes del cual depende y es marcando la opción Install dependencies en la ventana anterior (Install Packages).",
    "crumbs": [
      "Primeros pasos y generalidades"
    ]
  },
  {
    "objectID": "pasos.html#lectura-de-archivos-de-datos",
    "href": "pasos.html#lectura-de-archivos-de-datos",
    "title": "Primeros pasos y generalidades",
    "section": "Lectura de archivos de datos",
    "text": "Lectura de archivos de datos\nEl lenguaje nos permite importar variados formatos de tablas de datos utilizando funciones propias de R base como de paquetes que se dedican a esta tarea.\nEl formato nativo de tablas de datos de R es el texto plano (ASCII - Codigo Estadounidense Estandar para el Intercambio de Informacion) con sus columnas separadas por algún caracter. Estos pueden ser caracteres habituales como la coma (,) o el punto y coma (;) que da lugar a la extensión *.csv, o algunos especiales como la barra vertical (|) que suele utilizar el INDEC para sus productos o bien cualquier otro, como espacios o la tabulación.\nOtra característica que tienen estos archivos es que generalmente poseen una cabecera donde se ubican los nombres de cada columna/variable y por supuesto que cada una de ellas debe respetar un mismo tipo de dato para cumplir con la condición que la hace una tabla/base de datos.\nLo más importante para hacer una buena lectura de la tabla de datos con la que deseamos trabajar es conocer previamente el formato que tiene, si tiene cabecera, que caracter usa como separador de columnas, etc. Al ser un texto plano se puede abrir desde un simple Block de Notas de Windows o desde el mismo RStudio para conocer sus particularidades.",
    "crumbs": [
      "Primeros pasos y generalidades"
    ]
  },
  {
    "objectID": "pasos.html#buenas-prácticas",
    "href": "pasos.html#buenas-prácticas",
    "title": "Primeros pasos y generalidades",
    "section": "Buenas prácticas",
    "text": "Buenas prácticas\n\nUtilizar siempre proyectos de RStudio (Rproj)\nIniciar los scripts con las líneas de activación de paquetes necesarios para ejecutar las funciones incluídas en el código. ( función library() )\nDocumentar el código por medio de comentarios (iniciados con #)\nUtilizar espacios e identación adecuada para que el código sea de fácil lectura. Para ayudar a mejorar la legibilidad y facilitar el compartir código con otros, existe una guía de estilo no oficial para escribir código R. Es bastante breve y tiene muchos ejemplos de buenas y malas formas de escribir código (nombrar variables, manejar líneas largas, usar niveles de sangría adecuados, etc.). La pueden encontrar en https://style.tidyverse.org/",
    "crumbs": [
      "Primeros pasos y generalidades"
    ]
  },
  {
    "objectID": "EDA.html",
    "href": "EDA.html",
    "title": "Análisis exploratorio de datos (EDA)",
    "section": "",
    "text": "Este material es parte de la Unidad 1 del curso de Epidemiología - Nivel Avanzado  © 2025 Instituto Nacional de Epidemiología “Dr. Juan H. Jara” (ANLIS) -  CC BY-NC 4.0",
    "crumbs": [
      "Análisis exploratorio de datos (EDA)"
    ]
  },
  {
    "objectID": "EDA.html#introducción",
    "href": "EDA.html#introducción",
    "title": "Análisis exploratorio de datos (EDA)",
    "section": "Introducción",
    "text": "Introducción\nEl análisis exploratorio de datos (conocido como EDA, su sigla en inglés) es un enfoque de análisis de datos para resumir y visualizar las características importantes de un conjunto de datos.\nJohn Tukey, estadístico estadounidense, fue el principal propulsor contribuyendo de manera significativa al desarrollo del análisis exploratorio de datos al publicar, en 1977, su libro que lleva ese nombre donde entre otras cosas introdujo el gráfico boxplot (diagrama de caja y bigotes).\nEn términos simples, antes de avanzar con la etapa analítica y de construir modelos estadísticos, es relevante explorar, conocer y describir las variables de interés en nuestra tabla de datos.\nLos principales objetivos perseguidos por EDA son:\n\nConocer la estructura de la tabla de datos y sus tipos de variable\nDetectar observaciones incompletas (valores missing)\nConocer la distribución de las variables de interés a partir de:\n\nResumir datos mediante estadísticos\nResumir datos mediante gráficos\n\nDetectar valores atípicos (outlier)\n\nAclaración: En este documento mostraremos funciones del lenguaje R que se pueden aplicar en este proceso basadas en la filosofía tidyverse. También aplicaremos otros paquetes diseñados para tareas específicas que le serán de mucha utilidad. Esto no quiere decir que no se pueda hacer la misma exploración con funciones del R base pero el ecosistema facilita el entendimiento de lo que estamos haciendo.\nPresentaremos estas diferentes funciones de distintos paquetes que pueden servir en cada etapa de un EDA. Los paquetes con los que trabajaremos son:\n\ntidyverse\nskimr\ndlookr\njanitor\n\nPara instalarlos puede copiar y ejecutar el siguiente código:\n\ninstall.packages(c(\"tidyverse\", \"skimr\", \"janitor\", \"dlookr\"))\n\nNota: Algunos paquetes, entre estos dlookr, pueden ocasionar un falso positivo en la detección del antivirus durante el proceso de instalación. Sugerimos que desactive momentáneamente su antivirus para instalarlo sin inconvenientes.\nUna vez instalados los podemos activar:\n\nlibrary(skimr)\nlibrary(janitor)\nlibrary(dlookr)\nlibrary(tidyverse)\n\nCabe aclarar que no existe un solo camino y/o función del lenguaje para obtener la información requerida y que esta selección de paquetes puede cambiarse y ampliarse según la conveniencia del usuario. Es decir, aquellxs estudiantes que ya utilicen R y estén familiarizados con funciones y/o paquetes que realicen la misma tarea pueden seguir usándolos.\nCon el fin de ejemplificar este análisis exploratorio vamos a utilizar un archivo con datos ficticios y variables de distinto tipo.\n\nConocer la estructura de la tabla de datos y sus tipos de variable\nEl primer paso en la exploración de un conjunto de datos es conocer su estructura y tamaño.\nEl tamaño está definido por la cantidad de observaciones (filas) y la cantidad de variables (columnas).\nLlamamos estructura a la forma en se organizan sus variables, sus tipos de datos y sus categorías/valores.\n\ndatos &lt;- read_csv2(\"datos/datos2.txt\")\n\nLa función glimpse() del tidyverse le da un vistazo a los datos:\n\nglimpse(datos)\n\nRows: 74\nColumns: 7\n$ id      &lt;dbl&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18,…\n$ sexo    &lt;chr&gt; \"M\", \"M\", \"M\", \"M\", \"M\", \"M\", \"M\", \"M\", NA, \"F\", \"F\", \"M\", \"F\"…\n$ edad    &lt;dbl&gt; 76, 68, 50, 49, 51, 68, 70, 64, 60, 57, 83, 76, 27, 34, 17, 45…\n$ peso    &lt;dbl&gt; 71, 71, 79, 71, 87, 75, 80, 83, 69, 73, 60, 70, 648, 718, 61, …\n$ talla   &lt;dbl&gt; 167, 164, 164, 164, 1675, 170, 166, 160, 160, 155, 155, 167, 1…\n$ trabaja &lt;lgl&gt; FALSE, FALSE, FALSE, TRUE, TRUE, FALSE, NA, TRUE, TRUE, TRUE, …\n$ fecha   &lt;date&gt; 2020-10-20, 2020-10-20, 2020-10-20, 2020-11-05, 2020-11-05, 2…\n\n\nNos informa que la tabla tiene 74 observaciones, 7 variables con su tipo de dato y los primeros valores de cada una al lado.\nLos tipos de datos que nos podemos encontrar son:\n\nint (integer): números enteros\ndbl (double): números reales\nlgl (logical): valores lógicos\nchr (character): caracteres (texto)\nDate: fechas\nfct (factor): factores\ndttm (date-time): fechas y horas\n\nEsta exploración inicial de la estructura generalmente viene acompañada por el “diccionario de datos” asociado a la tabla de datos, ya sea que esta tabla provenga de un proyecto de investigación propio (fuente primaria) o producto de una fuente secundaria.\nEn algunas situaciones el tipo de dato del dato coincidirá con la clasificación de la variable (por ejemplo, que sea numérica -dbl- para variables cuantitativas continuas) pero en otros casos podemos tener variables codificadas donde el dato es numérico pero representa una categoría de una variable cualitativa (por ejemplo, si a una variable de respuesta Si - No, la codificamos como 1 y 0).\n\n\nDetectar observaciones incompletas (valores missing)\nSabemos que los valores perdidos o faltantes (conocidos en inglés como missing), que se gestionan en R mediante el valor especial reservado NA, constituyen un serio problema en nuestras variables de análisis.\nExisten numerosos libros sobre como tratarlos y sobre diversos algoritmos de imputación que no vamos a incluir en este curso.\nSólo vamos a enfocarnos en como podemos utilizar algunas funciones de R para detectarlos, contabilizarlos y en algunas situaciones excluirlos.\nCada vez que ejecutemos un count() a una variable nos informará, al final de la tabla de salida, la cantidad de valores NA.\n\ndatos |&gt; \n  count(trabaja)\n\n# A tibble: 3 × 2\n  trabaja     n\n  &lt;lgl&gt;   &lt;int&gt;\n1 FALSE      26\n2 TRUE       39\n3 NA          9\n\n\nMucho mejor es la función find_na() que proviene del paquete dlookr:\n\nfind_na(datos, rate = T)\n\n     id    sexo    edad    peso   talla trabaja   fecha \n  0.000   4.054   0.000   0.000   0.000  12.162   0.000 \n\n\nPodemos aplicarla a todo el dataframe y nos dice que porcentaje de valores NA hay en cada variable. En este ejemplo la variable sexo tiene alrededor de un 4 % de valores faltantes y trabaja un poco más de 12 %.\nEstos porcentajes, siempre y cuando los NA sean el resultado de la falta de dato, nos hará decidir si una variable es apropiada para incluirla en un análisis y/o si conviene excluir observaciones con esa situación.\nEl mismo paquete trae una función gráfica llamada plot_na_pareto():\n\nplot_na_pareto(datos, only_na = T)\n\n\n\n\n\n\n\n\nAlgo mas completo se logra con diagnose() (también de dlookr) que diagnostica la calidad de las variables:\n\ndiagnose(datos)\n\n# A tibble: 7 × 6\n  variables types     missing_count missing_percent unique_count unique_rate\n  &lt;chr&gt;     &lt;chr&gt;             &lt;int&gt;           &lt;dbl&gt;        &lt;int&gt;       &lt;dbl&gt;\n1 id        numeric               0            0              74      1     \n2 sexo      character             3            4.05            3      0.0405\n3 edad      numeric               0            0              45      0.608 \n4 peso      numeric               0            0              56      0.757 \n5 talla     numeric               0            0              38      0.514 \n6 trabaja   logical               9           12.2             3      0.0405\n7 fecha     Date                  0            0              11      0.149 \n\n\n\n\nConocer la distribución de las variables de interés\n\nResumir variables cuantitativas mediante estadísticos\nLa instalación básica de R tiene incorporadas muchas funciones estadísticas con las cuales calcular medidas resumen de variables cuantitativas que podemos incluir dentro de los resúmenes de tidyverse.\nMedidas de tendencia central\nEstas medidas son parte de las medidas de posición o localización, pero tiene la intención de resumir la información en torno a un valor central, respecto al cual parece agruparse de un modo más o menos concentrado la distribución de los demás valores.\n\ndatos |&gt;\n  summarise(media = mean(edad), # media\n            mediana = median(edad))  # mediana \n\n# A tibble: 1 × 2\n  media mediana\n  &lt;dbl&gt;   &lt;dbl&gt;\n1  48.1    52.5\n\n\nEn cambio, no hay ninguna función base que calcule la moda. Tendremos que escribir una forma de cálculo o bien buscar y activar algún paquete extra de las numerosas librerías que tiene el lenguaje R que la tenga implementada.\nMedidas de posición\nLas medidas de posición dividen un conjunto de datos en grupos con el mismo número de individuos. Entre los más utilizados tenemos los cuartiles y percentiles.\nPor ejemplo, con la función quantile(), del paquete stats, calculamos los cuartiles Q1 y Q3. Indicamos como argumento los valores 0.25 y 0.75.\n\ndatos |&gt;\n  summarise(cuartil1 = quantile(edad, probs = 0.25),\n            cuartil3 = quantile(edad, probs = 0.75))\n\n# A tibble: 1 × 2\n  cuartil1 cuartil3\n     &lt;dbl&gt;    &lt;dbl&gt;\n1       28       64\n\n\nSi queremos obtener el mínimo y máximo de este conjunto de valores numéricos podemos hacerlo con:\n\ndatos |&gt;\n  summarise(minimo = min(edad),\n            maximo = max(edad))\n\n# A tibble: 1 × 2\n  minimo maximo\n   &lt;dbl&gt;  &lt;dbl&gt;\n1     13     86\n\n\nMedidas de dispersión\nCuando intentamos saber que tan dispersos están los valores o que tan variables son los datos dentro del conjunto de datos, usamos estadísticos de dispersión.\nLos clásicos conocidos como la varianza var() y el desvío estándar sd() se pueden aplicar directamente al summarise():\n\ndatos |&gt;\n  summarise(varianza = var(edad),\n            desvio = sd(edad))\n\n# A tibble: 1 × 2\n  varianza desvio\n     &lt;dbl&gt;  &lt;dbl&gt;\n1     405.   20.1\n\n\nTambién se puede calcular el rango y el rango intercuartílico.\nPara el primero debemos hacer la diferencia entre el máximo y el mínimo, en cambio para el RIC se usa la función IQR() que devuelve el rango entre el tercer y el primer cuartil de una distribución:\n\ndatos |&gt;\n  summarise(rango = max(edad)-min(edad),\n            ric = IQR(edad))\n\n# A tibble: 1 × 2\n  rango   ric\n  &lt;dbl&gt; &lt;dbl&gt;\n1    73    36\n\n\nEn dlookr tenemos la función describe() dedicada a describir variables numéricas.\n\ndescribe(datos, -id)\n\n# A tibble: 3 × 26\n  described_variables     n    na  mean    sd se_mean   IQR skewness kurtosis\n  &lt;chr&gt;               &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt;    &lt;dbl&gt;    &lt;dbl&gt;\n1 edad                   74     0  48.1  20.1    2.34  36     -0.211    -1.11\n2 peso                   74     0 358.  323.    37.6  626.     0.451    -1.41\n3 talla                  74     0 363.  505.    58.7   12.8    2.19      2.90\n# ℹ 17 more variables: p00 &lt;dbl&gt;, p01 &lt;dbl&gt;, p05 &lt;dbl&gt;, p10 &lt;dbl&gt;, p20 &lt;dbl&gt;,\n#   p25 &lt;dbl&gt;, p30 &lt;dbl&gt;, p40 &lt;dbl&gt;, p50 &lt;dbl&gt;, p60 &lt;dbl&gt;, p70 &lt;dbl&gt;,\n#   p75 &lt;dbl&gt;, p80 &lt;dbl&gt;, p90 &lt;dbl&gt;, p95 &lt;dbl&gt;, p99 &lt;dbl&gt;, p100 &lt;dbl&gt;\n\n\nObservemos que se puede aplicar sobre la tabla de datos completa. La propia función seleccionará las variables numéricas, pero con -id le estamos indicando que no tome en cuenta la variable id (el identificador es una variable que no tiene sentido analizar estadísticamente).\nLos resultados comprenden: observaciones con datos, observaciones con valores NA, media, desvío estandar, error de la media, intervalo intercuartílico, medidas de forma como la simetría (skewness) y la curtosis (kurtosis) y los quintiles (incluye la mediana p50 y los cuartiles p25-p75).\n\n\nResumir variables cualitativas mediante estadísticos\nLas variables cualitativas o categóricas pueden encontrarse bajo el tipo de dato character o factor. Ocasionalmente vamos a necesitar que las variables se encuentren bajo este último formato que el lenguaje R reserva para efectuar algunos procedimientos con estas variables.\nFrecuencias y tablas de contingencia\nPodemos resumir individualmente variables de tipo cualitativo mediante las frecuencias absolutas y relativas de sus categorías. La función count() nos muestra el conteo absoluto de las diferentes categorías de la variable:\n\ndatos |&gt; \n  count(sexo)\n\n# A tibble: 3 × 2\n  sexo      n\n  &lt;chr&gt; &lt;int&gt;\n1 F        27\n2 M        44\n3 &lt;NA&gt;      3\n\n\nEn la salida, además de las categorías explícitas, aparece el valor NA con un conteo de 3 observaciones.\nTener en cuenta o no los valores faltantes es una decisión propia del que conduce el análisis y puede cambiar dependiendo de los objetivos buscados.\nUna forma de evitarlos con count() es utilizar luego la función drop_na():\n\ndatos |&gt; \n  count(sexo) |&gt; \n  drop_na()  # saltea los valores NA\n\n# A tibble: 2 × 2\n  sexo      n\n  &lt;chr&gt; &lt;int&gt;\n1 F        27\n2 M        44\n\n\nObtenemos frecuencias relativas porcentuales así:\n\ndatos |&gt;  \n  count(sexo) |&gt;  \n  drop_na() |&gt; \n  mutate(porc = 100*n/sum(n))\n\n# A tibble: 2 × 3\n  sexo      n  porc\n  &lt;chr&gt; &lt;int&gt; &lt;dbl&gt;\n1 F        27  38.0\n2 M        44  62.0\n\n\nRedondeamos el valor del porcentaje con round():\n\ndatos |&gt;  \n  count(sexo) |&gt;  \n  drop_na() |&gt; \n  mutate(porc = 100*n/sum(n),\n         porc = round(porc, digits = 2))\n\n# A tibble: 2 × 3\n  sexo      n  porc\n  &lt;chr&gt; &lt;int&gt; &lt;dbl&gt;\n1 F        27  38.0\n2 M        44  62.0\n\n\nUna opción más completa es utilizar funciones del paquete janitor como tabyl():\n\ndatos |&gt;\n  tabyl(sexo)\n\n sexo  n    percent valid_percent\n    F 27 0.36486486     0.3802817\n    M 44 0.59459459     0.6197183\n &lt;NA&gt;  3 0.04054054            NA\n\n\nCalcula las frecuencias relativas incluyendo y no incluyendo los valores NA (porcentaje de valores válidos).\nPodemos modificar sus argumentos y asociar otras funciones del paquete mediante tuberías para obtener mejores resultados (es compatible con tidyverse).\n\ndatos |&gt;  \n  tabyl(sexo, show_na = F) |&gt; # anulamos valores na\n  adorn_totals(where = \"row\") |&gt; # agregamos totales \n  adorn_pct_formatting(digits = 2) # porcentaje con dos decimales\n\n  sexo  n percent\n     F 27  38.03%\n     M 44  61.97%\n Total 71 100.00%\n\n\nTablas de contingencia\nLa forma más adecuada de describir la relación entre dos variables categóricas es a partir de la construcción de una tabla de contingencia. Para ello se introduce en cada fila de la tabla las categorías de una de las variables y las categorías de la otra variable se asocian a cada una de las columnas de la tabla, en cada celda de la tabla aparecerá el número de observaciones correspondientes a la combinación oportuna de ambas variables.\nCon la misma función tabyl() se puede realizar una tabla de contingencia, incluyendo a la variable trabaja (aunque tenga formato lógico puede utilizarse igual si conceptualmente la variable es categórica):\n\ndatos |&gt;  \n  tabyl(sexo, trabaja) \n\n sexo FALSE TRUE NA_\n    F     8   15   4\n    M    17   22   5\n &lt;NA&gt;     1    2   0\n\n\nRecordemos que en orden dentro de los paréntesis de la función es igual al de los índices, el primer argumento es la variable que aparecerá en las filas y el segundo la variable de las columnas. Por ese motivo, en la tabla de contingencia absoluta tenemos el sexo en las filas y a trabaja en las columnas.\nSe puede mejorar sin valores NA y agregando totales:\n\ndatos |&gt;  \n  tabyl(sexo, trabaja, show_na = F) |&gt; \n  adorn_totals(where = \"row\")\n\n  sexo FALSE TRUE\n     F     8   15\n     M    17   22\n Total    25   37\n\n\nCalculamos frecuencias relativas porcentuales por columna:\n\ndatos |&gt;  \n  tabyl(sexo, trabaja, show_na = F) |&gt; \n  adorn_totals(where = \"row\") |&gt; \n  adorn_percentages(denominator = \"col\") |&gt; #  % por columna\n  adorn_pct_formatting(digits = 2) # redondea con 2 decimales\n\n  sexo   FALSE    TRUE\n     F  32.00%  40.54%\n     M  68.00%  59.46%\n Total 100.00% 100.00%\n\n\nCalculamos frecuencias relativas porcentuales por fila:\n\ndatos |&gt;  \n  tabyl(sexo, trabaja, show_na = F) |&gt; \n  adorn_totals(where = \"col\") |&gt; \n  adorn_percentages(denominator = \"row\") |&gt; #  % por fila\n  adorn_pct_formatting(digits = 2) # redondea con 2 decimales\n\n sexo  FALSE   TRUE   Total\n    F 34.78% 65.22% 100.00%\n    M 43.59% 56.41% 100.00%\n\n\nCambiando el argumento denominator de adorn_percentages() a “all” se calculan relativas al total.\n\ndatos |&gt;  \n  tabyl(sexo, trabaja, show_na = F) |&gt; \n  adorn_totals(where = \"col\") |&gt; \n  adorn_percentages(denominator = \"all\") |&gt; #  % por total\n  adorn_pct_formatting(digits = 2) # redondea con 2 decimales\n\n sexo  FALSE   TRUE  Total\n    F 12.90% 24.19% 37.10%\n    M 27.42% 35.48% 62.90%\n\n\n\n\nExplorar variables mediante gráficos\nUno de los aportes más relevantes de Tukey respecto al análisis es el uso de los gráficos cómo método exploratorio.\nLos gráficos básicos más útiles que muestran la distribución univariada de variables que podemos hacer con R son:\n\nvariables cuantitativas: histogramas, densidad, boxplot y violinplot.\nvariables cualitativas: barras\n\nCuando interviene más de una variable aparecen comúnmente los puntos, las líneas y los gráficos de mosaico.\nEl lenguaje R soporta una serie de sistemas gráficos asociados a paquetes como graphics, lattice, ggplot2, etc. que sirven de base incluso para otros paquetes con funciones más específicas. Actualmente el estándar gráfico en R es ggplot2.\nEn el documento referido a tidyverse explicamos el funcionamiento de ggplot2 y sus capas gráficas.\nAhora sólo ejecutaremos los distintos elementos geométricos para representar los diferentes gráficos mencionados.\nBarras en univariado\n\n\n\n\n\n\n\n\n\nBarras en bivariado - posición stack\n\n\n\n\n\n\n\n\n\nBarras en bivariado - posición dodge\n\n\n\n\n\n\n\n\n\nBarras en bivariado - posición fill\n\n\n\n\n\n\n\n\n\nHistograma\n\n\n\n\n\n\n\n\n\nDensidad\n\n\n\n\n\n\n\n\n\nBoxplot\n\n\n\n\n\n\n\n\n\nViolinplot\n\n\n\n\n\n\n\n\n\nQ-Q Plot\nLos Q-Q Plot (Cuantil-Cuantil) son gráficos especiales que permiten observar cuan cerca está la distribución de un conjunto de datos a alguna distribución ideal o comparar la distribución de dos conjuntos de datos.\nSuele usarse como método gráfico para analizar “normalidad”, es decir cuanto se asemeja la distribución de la variable a la distribución normal (“gaussiana”).\nLa función plot_normality() de dlookr muestra un diagnóstico gráfico de normalidad de una variable usando histogramas y Q-Q plot. Además muestra otros histogramas con conversiones de datos (logarítmico y raíz cuadrada por defecto, pero también “Box-Cox” y otras)\nSobre la variable edad:\n\ndatos |&gt; \n  plot_normality(edad)\n\n\n\n\n\n\n\n\nSobre la variable peso:\n\ndatos |&gt; \n  plot_normality(peso)\n\n\n\n\n\n\n\n\nEn la comparación podemos decir que los puntos se desarrollan mas cercanos a la línea teórica normal para la variable peso que para la variable edad.\nEstos gráficos siempre se analizan acompañados por test de bondad de ajuste específicos de normalidad que veremos en la unidad 2.\n\n\n\nDetectar valores atípicos (outlier)\nUn valor atípico (en inglés outlier) es una observación que está numéricamente distante del resto de los datos.\nLos outliers pueden deberse a:\n\nErrores de carga o procedimiento (se deben reparar)\nValores extremos posibles (hay que evaluarlos)\nAcontecimientos extraordinarios o causas desconocidas (suelen eliminarse)\n\nEstos valores desproporcionados pueden conducir a interpretar erróneamente algunos estadísticos como la media, ya que los distorsionan.\nUna forma habitual de detección es mediante los gráficos boxplot.\nVeamos el ejemplo con la variable peso donde existe un valor considerado atípico en el extremo superior de la distribución (punto rojo):\n\n\n\n\n\n\n\n\n\nCoincide con el valor máximo de 1105 kgrs.\nDentro de los paquetes incluidos en este documento la función diagnose_outlier() de dlookr esta pensada para la detección de datos atípicos.\n\ndiagnose_outlier(datos)\n\n# A tibble: 4 × 6\n  variables outliers_cnt outliers_ratio outliers_mean with_mean without_mean\n  &lt;chr&gt;            &lt;int&gt;          &lt;dbl&gt;         &lt;dbl&gt;     &lt;dbl&gt;        &lt;dbl&gt;\n1 id                   0            0             NaN      37.5         37.5\n2 edad                 0            0             NaN      48.1         48.1\n3 peso                 0            0             NaN     358.         358. \n4 talla               10           13.5          1630     363.         165. \n\n\nSe puede aplicar a todo el conjunto de datos y nos devuelve una tabla con la cantidad de outliers detectados por variable, la proporción, la media considerando estos valores y la media sin considerarlos.\nEn función de estos dos estadísticos se puede comparar el efecto de los valores atípicos en la media.\n\n\nskimr\nFinalmente una función interesante por lo sencillo de su uso es skim() de skimr.\n\nskim(datos)\n\n\nData summary\n\n\nName\ndatos\n\n\nNumber of rows\n74\n\n\nNumber of columns\n7\n\n\n_______________________\n\n\n\nColumn type frequency:\n\n\n\ncharacter\n1\n\n\nDate\n1\n\n\nlogical\n1\n\n\nnumeric\n4\n\n\n________________________\n\n\n\nGroup variables\nNone\n\n\n\nVariable type: character\n\n\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nmin\nmax\nempty\nn_unique\nwhitespace\n\n\n\n\nsexo\n3\n0.96\n1\n1\n0\n2\n0\n\n\n\nVariable type: Date\n\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nmin\nmax\nmedian\nn_unique\n\n\n\n\nfecha\n0\n1\n2020-10-20\n2020-12-15\n2020-11-11\n11\n\n\n\nVariable type: logical\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nmean\ncount\n\n\n\n\ntrabaja\n9\n0.88\n0.6\nTRU: 39, FAL: 26\n\n\n\nVariable type: numeric\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nmean\nsd\np0\np25\np50\np75\np100\nhist\n\n\n\n\nid\n0\n1\n37.50\n21.51\n1\n19.25\n37.5\n55.75\n74\n▇▇▇▇▇\n\n\nedad\n0\n1\n48.07\n20.12\n13\n28.00\n52.5\n64.00\n86\n▇▃▇▇▃\n\n\npeso\n0\n1\n358.05\n323.31\n42\n75.00\n91.5\n700.50\n1105\n▇▁▂▃▁\n\n\ntalla\n0\n1\n363.09\n504.93\n148\n161.00\n166.0\n173.75\n1745\n▇▁▁▁▁\n\n\n\n\n\nMuestra en una tabla características y estadísticos descriptivos de las variables del dataframe y se puede combinar dentro de estructuras tidyverse con tuberías.\n\ndatos |&gt; \n  drop_na(sexo) |&gt;\n  group_by(sexo) |&gt;\n  select(where(is.numeric), -id) |&gt;  # solo variables numéricas - id\n  skim()\n\n\nData summary\n\n\nName\nselect(…)\n\n\nNumber of rows\n71\n\n\nNumber of columns\n4\n\n\n_______________________\n\n\n\nColumn type frequency:\n\n\n\nnumeric\n3\n\n\n________________________\n\n\n\nGroup variables\nsexo\n\n\n\nVariable type: numeric\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nsexo\nn_missing\ncomplete_rate\nmean\nsd\np0\np25\np50\np75\np100\nhist\n\n\n\n\nedad\nF\n0\n1\n41.89\n19.64\n15\n26.00\n39.0\n54.50\n83\n▇▃▅▃▂\n\n\nedad\nM\n0\n1\n51.59\n19.56\n13\n40.75\n55.5\n64.75\n86\n▅▂▅▇▂\n\n\npeso\nF\n0\n1\n426.78\n300.85\n42\n70.50\n516.0\n677.00\n856\n▇▁▃▃▆\n\n\npeso\nM\n0\n1\n306.95\n331.27\n64\n78.00\n86.5\n647.00\n1105\n▇▁▁▂▁\n\n\ntalla\nF\n0\n1\n421.74\n562.57\n148\n155.50\n161.0\n167.50\n1625\n▇▁▁▁▂\n\n\ntalla\nM\n0\n1\n340.77\n485.79\n158\n164.00\n168.5\n177.25\n1745\n▇▁▁▁▁\n\n\n\n\n\nEn este ejemplo, mostramos resultados de variables numéricas menos de id agrupados por sexo (sin considerar valores NA en las categorías de sexo)",
    "crumbs": [
      "Análisis exploratorio de datos (EDA)"
    ]
  },
  {
    "objectID": "estilo.html",
    "href": "estilo.html",
    "title": "Hoja de Estilo del lenguaje R",
    "section": "",
    "text": "Este material es parte de la Unidad 1 del curso de Epidemiología - Nivel Avanzado  © 2025 Instituto Nacional de Epidemiología “Dr. Juan H. Jara” (ANLIS) -  CC BY-NC 4.0",
    "crumbs": [
      "Hoja de Estilo del lenguaje R"
    ]
  },
  {
    "objectID": "estilo.html#convenciones-de-estilo-r",
    "href": "estilo.html#convenciones-de-estilo-r",
    "title": "Hoja de Estilo del lenguaje R",
    "section": "Convenciones de estilo R",
    "text": "Convenciones de estilo R\nR es bastante indulgente con la forma en que escribimos código (a diferencia de otros lenguajes como Python, donde contar mal los espacios puede arruinar el trabajo).\nTodas estas cosas harán exactamente lo mismo:\n\nmpg |&gt; \n  filter(cty &gt; 10, class == \"compact\")\n\nmpg |&gt; filter(cty &gt; 10, class == \"compact\")\n\nmpg |&gt; \n  filter(cty &gt; 10, \n         class == \"compact\")\n\nmpg |&gt; filter(cty&gt;10, class==\"compact\")\n\nfilter(mpg,cty&gt;10,class==\"compact\")\n\nmpg |&gt; \nfilter(cty &gt; 10, \n                        class == \"compact\")\n\nfilter ( mpg,cty&gt;10,     class==\"compact\" )\n\nPero es evidente que sólo algunas de esas porciones de código (las primeras tres) son más fáciles de leer.\nPara ayudar a mejorar la legibilidad y facilitar el compartir código con otros, existe una guía de estilo, publicada por el equipo de Tidyverse, para escribir código R. Es bastante breve y tiene muchos ejemplos de buenas y malas formas de escribir código (nombrar variables, manejar líneas largas, usar niveles de sangría adecuados, etc.).\nSu enlace es https://style.tidyverse.org/\nRStudio tiene una forma integrada de reidentar el código. Si seleccionamos la porción que deseamos y presionamos el atajo de teclado Ctrl + i (en Windows) R reformateará el código por nosotros. No siempre es perfecto, pero es realmente útil para lograr la sangría correcta sin tener que presionar manualmente espacio muchas veces.",
    "crumbs": [
      "Hoja de Estilo del lenguaje R"
    ]
  },
  {
    "objectID": "estilo.html#elementos-más-sobresalientes",
    "href": "estilo.html#elementos-más-sobresalientes",
    "title": "Hoja de Estilo del lenguaje R",
    "section": "Elementos más sobresalientes",
    "text": "Elementos más sobresalientes\n\nEspaciado\nColoque espacios después de las comas\n\n# Bien\nfilter(mpg, cty &gt; 10)\n\n# Mal\nfilter(mpg , cty &gt; 10)\nfilter(mpg ,cty &gt; 10)\nfilter(mpg,cty &gt; 10)\n\nColoque espacios alrededor de operadores como +, -, &gt;, =, etc.:\n\n# Bien\nfilter(mpg, cty &gt; 10)\n\n# Mal\nfilter(mpg, cty&gt;10)\nfilter(mpg, cty&gt; 10)\nfilter(mpg, cty &gt;10)\n\nNo coloque espacios alrededor de paréntesis que sean parte de funciones:\n\n# Bien\nfilter(mpg, cty &gt; 10)\n\n# Mal\nfilter (mpg, cty &gt; 10)\nfilter ( mpg, cty &gt; 10)\nfilter( mpg, cty &gt; 10 )\n\n\n\nLíneas largas\nEn general, es una buena práctica no tener líneas de código muy largas. Una buena sugerencia es mantener las líneas con un máximo de 80 caracteres. En lugar de contar caracteres a mano, en RStudio vaya a Tools &gt; Global Options &gt; Code &gt; Display y seleccione la casilla Show margin. Ahora deberías ver una línea muy delgada que indica 80 caracteres.\nConviene agregar saltos de línea dentro de líneas de código más largas. Los saltos de línea deben ir después de las comas y cosas como los argumentos de la función deben alinearse dentro de la función:\n\n# Bien\nfilter(mpg, cty &gt; 10, class == \"compact\")\n\n# Bien\nfilter(mpg, cty &gt; 10, \n       class == \"compact\")\n\n# Bien\nfilter(mpg,\n       cty &gt; 10,\n       class == \"compact\")\n\n# Mal\nfilter(mpg, cty &gt; 10, class %in% c(\"compact\", \"pickup\", \"midsize\", \"subcompact\", \"suv\", \"2seater\", \"minivan\"))\n\n# Bien\nfilter(mpg, \n       cty &gt; 10, \n       class %in% c(\"compact\", \"pickup\", \"midsize\", \"subcompact\", \n                    \"suv\", \"2seater\", \"minivan\"))\n\n\n\nTuberías (%&gt;% o |&gt;) y capas en ggplot2 (+)\nColoque cada capa de un gráfico ggplot en líneas separadas, con el + al final de la línea y debajo sangría de dos espacios:\n\n# Bien\nggplot(mpg, aes(x = cty, y = hwy, color = class)) +\n  geom_point() +\n  geom_smooth() +\n  theme_bw()\n\n# Mal\nggplot(mpg, aes(x = cty, y = hwy, color = class)) +\n  geom_point() + geom_smooth() +\n  theme_bw()\n\n# Muy mal\nggplot(mpg, aes(x = cty, y = hwy, color = class)) + geom_point() + geom_smooth() + theme_bw()\n\n# Tan mal que no funciona\nggplot(mpg, aes(x = cty, y = hwy, color = class))\n  + geom_point()\n  + geom_smooth() \n  + theme_bw()\n\nColoque cada paso de una tubería en líneas separadas, con el %&gt;% o |&gt; al final de la línea y debajo una sangría de dos espacios:\n\n# Bien\nmpg |&gt; \n  filter(cty &gt; 10) |&gt; \n  group_by(class) |&gt; \n  summarize(avg_hwy = mean(hwy))\n\n# Mal\nmpg |&gt; filter(cty &gt; 10) |&gt; group_by(class) |&gt; \n  summarize(avg_hwy = mean(hwy))\n\n# Muy mal\nmpg |&gt; filter(cty &gt; 10) |&gt; group_by(class) |&gt; summarize(avg_hwy = mean(hwy))\n\n# Tan mal que no funciona\nmpg |&gt; \n  filter(cty &gt; 10)\n  |&gt; group_by(class)\n  |&gt; summarize(avg_hwy = mean(hwy))\n\n\n\nComentarios\nLos comentarios deben comenzar con un símbolo de comentario y un solo espacio: #\n\n# Bien\n\n#Mal\n\n    #Mal\n\nSi el comentario es muy corto (y no provoca que se supere los 80 caracteres en la línea), se puede incluir en la misma línea del código, separado por al menos dos espacios (funciona con un espacio, pero usando un par puede mejorar la legibilidad):\n\nmpg %&gt;% \n  filter(cty &gt; 10) %&gt;%  # filtro filas donde cty es 10 o más\n  group_by(class) %&gt;%  # estratifica por class\n  summarize(avg_hwy = mean(hwy))  # resume la media de hwy por cada grupo\n\nSe puede agregar espacios adicionales para alinear los comentarios en línea, si lo deseamos:\n\nmpg %&gt;% \n  filter(cty &gt; 10) %&gt;%            # filtro filas donde cty es 10 o más\n  group_by(class) %&gt;%             # estratifica por class\n  summarize(avg_hwy = mean(hwy))  # resume la media de hwy por cada grupo\n\nSi el comentario es muy largo, podemos dividirlo en varias líneas. RStudio tiene una herramienta en Code &gt; Reflow Comment que lo automatiza.",
    "crumbs": [
      "Hoja de Estilo del lenguaje R"
    ]
  }
]